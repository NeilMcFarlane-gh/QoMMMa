#!/usr/bin/python3

"""
// This is a helper QoMMMa Python file, which contains the functions used in execution of a Molpro job. //
"""

# Global imports.
import os
import shutil

# Local imports.
from qomutil import qomend     

def latdatin(imn):
    """
    
    // Function which creates the lattice point charge input file lat*.dat used in Molpro. //
    // This function is called in the function qmmolmain at each QoMMMa cycle. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.

    """
    
    # From the file charges*mol.xyz, the number of point charges is initialised.
    f = '%s%d%s'%('charges', imn, 'mol.xyz')
    count = len(open(f, 'r').readlines()) - 2
    
    # The file containing the lattice of point charges is created.
    fd = open(('%s%d%s'%('lat', imn, '.dat')), 'w')
    
    # The number of point charges is written.
    fd.write('\n')
    fd.write(str(count))
    fd.write('\n')
    
    # The point charges are written to lat*.dat.
    fc = open(f, 'r')
    for line in fc:
        if line.strip() != '&pointch':
            if line.strip() != '&':
                line = line.split()
                fd.write(line[1].rjust(13))
                fd.write(line[2].rjust(13))
                fd.write(line[3].rjust(13))
                fd.write(line[0].rjust(10))
                fd.write(line[4].rjust(5))
                fd.write('\n')
    fd.close()
    fc.close()    

def molinp(imn, cwd, qmjob_prefix, nqm, nlink):
    """
    
    // Function which creates the input file required for a Molpro job. //
    // This function is called in the function qmmolmain at each QoMMMa cycle. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.
    cwd : string
        The current working directory.
    qmjob_prefix : string
        A prefix used to label the QM job input file.
    nqm : integer
        Number of QM atoms.
    nlink : integer
        Number of link atoms.

    """
    
    # The Molpro input file is created for the image.
    fd = open(('%s%d%s'%(qmjob_prefix, imn, '.in')), 'w')  

    # The file qmheader is used to write header details to the input file.
    f = open((cwd + '/qmheader'), 'r')
    for line in f:
       fd.write(line)
    f.close()
    fd.write('\n')
    
    # The total number of atoms is written to the input file.
    ntot = int(nqm) + int(nlink)
    fd.write(str(ntot))
    fd.write('\n')
    fd.write('\n')
    
    # The cartesian coordinates of the QM region are written to the input file.
    f = open(('%s%d%s'%('qmgeom', imn, '.xyz')), 'r') 
    for line in f:
        fd.write(line)
    f.close()
    fd.write('}')
    fd.write('\n')
    
    # The point charges and lattice gradient file names are written to the input file.
    latinp = '%s%d%s'%('lat', imn, '.dat')
    latout = '%s%d%s'%('latgrad', imn, '.out')
    latline = 'lattice' + ' ' + '''\'''' + latinp + '''\'''' + ' ' + '''\'''' + latout + '''\''''
    fd.write(latline)
    fd.write('\n')
    
    # The file qmmol_footer is used to write footer details to the input file.    
    f = open((cwd + '/qmmol_footer'), 'r')
    for line in f:
        fd.write(line)
    f.close()
    fd.close() 

def molout(fi, l, nqm, nlink, cwd):
    """
    
    // Function which extracts the energy, forces and Mulliken charges from a Molpro output file. //
    
    Arguments
    ----------
    fi : string
        Molpro job output file name.
    l : integer
        If using the nudged elastic band, this is the image number.
    nqm : integer
        Number of QM atoms.
    nlink : integer
        Number of link atoms.
    cwd : string
        The current working directory.

    """
    
    # The output file containing QM energy and gradients is created.
    fds = open(('%s%d'%('ab_initio', l)), 'a')
    
    # The output file containing QM Mulliken charges is created.
    fdm = open(('%s%d'%('mulliken', l)), 'a')
    
    # A selection of files generated by Molpro, QoMMMa, and Tinker are opened.
    f = open(fi, 'r')
    flg = open(('%s%d%s'%('latgrad', l, '.out')), 'r')
    fqg = open(('%s%d%s'%('qmlatgrad', l, '.out')), 'a')
    fpg = open(('%s%d%s'%('points', l, 'gau.pts')), 'r')
    fgrad = str(len(fpg.readlines()))
    
    # While loop iterates through the whole Molpro output file.   
    while 1:
        line = f.readline()
        if not line:break
        
        # The atoms for which a gradient term will be required are initialised and saved in the list gradplace.
        # These atoms consist of the QM atoms and the link atoms.
        if line[:19] == ' ATOMIC COORDINATES':
            f.readline()
            f.readline()
            f.readline()
            gradplace = [' '] 
            for nqg in range(nqm + nlink):
                line = f.readline().split()
                hlp = line[1]
                for h in range(int(len(hlp))):
                    if hlp[h].isdigit():
                        place = hlp[h:]
                        break
                gradplace.append(int(place))
         
        # Molpro has multiple ways of noting the energy in the output file depending on the level of theory.
        # These various options are included in the below if statements and saved to the integer ene.    
        elif line[:23] == ' !RHF STATE 1.1 Energy ':
            ene=line.split()[4]
        elif line[:23] == ' !RKS STATE 1.1 Energy ':
            ene=line.split()[4]
        elif line[:23] == ' !MP2 STATE 1.1 Energy ':
            ene=line.split()[4]
        elif line[:23] == ' SCS-LMP2 total energy:':
            enescs=line.split()[3]
        elif line[:24] == ' !LMP2 STATE 1.1 Energy ':
            enelmp = line.split()[4]
            fq = open((cwd + '/qmmol_footer'),' r')
            for line in fq:
                if 'scsgrd=1' in str.lower(line):
                    ene = enescs
                    break
                else:
                    ene = enelmp
            fq.close()
        
        # The gradient terms which had been initialised in the list gradplace are read from the Molpro output file.    
        # Depending on the coordinates, these are added to tuples gradx, grady and gradz.
        elif line[:60] == ' Atom          dE/dx               dE/dy               dE/dz':
            f.readline()
            gradx = {}
            grady = {}
            gradz = {}
            ii = 0 
            for i in range(nqm + nlink):
                ii = ii + 1
                line = f.readline().split()
                gradx[gradplace[ii]] = line[1]
                grady[gradplace[ii]] = line[2]
                gradz[gradplace[ii]] = line[3]
        
        # The Mulliken population analysis generated by Molpro is read from the output file and added to the tuple cha.
        elif line[:43] == ' Population analysis by basis function type':
            f.readline()
            f.readline()
            cha = {}
            for nq in range(nqm + nlink):
                line = f.readline().split()
                sign = line[len(line) - 2]
                ncha = line[len(line) - 1]
                ncha = '%s%s'%(sign, ncha)
                place = int(line[0])
                cha[place] = ncha
      
    # The energy and gradient terms are written to the output file ab_initio*.
    fds.write('Energy')
    fds.write('\n')
    fds.write(ene)
    fds.write('\n')
    fds.write('Gradient')
    fds.write('\n')
    ii = 0
    tcha = 0.0
    for ig in range(nqm + nlink):
        ii = ii + 1
        fds.write(str(ii).rjust(3))      
        fds.write(gradx[ii].rjust(20))
        fds.write(grady[ii].rjust(20))
        fds.write(gradz[ii].rjust(20))
        fds.write('\n')
        tcha = tcha + float(cha[ii])
        fdm.write(cha[ii].rjust(10))
        fdm.write('\n')
     
    # Mulliken charges are written to the output file mulliken*.
    fdm.write('total charge')
    fdm.write('\n') 
    fdm.write(str(tcha))
    fdm.write('\n') 
    
    # The new lateral gradient is written to qmlatgrad*.out if it is greater than zero overall.
    fqg.write('gradient output')
    fqg.write('\n')
    fqg.write(fgrad)
    fqg.write('\n')
    latgrad = []
    lines = flg.readlines()
    for line in lines:
        if len(line.split()) < 3:
            pass
        elif line[:72] == '       0.000000000000000       0.000000000000000       0.000000000000000':
            pass 
        else:
            latgrad.append(line)
    fqg.writelines(latgrad)
    
    # All open files are closed.
    fqg.close()
    flg.close()
    fpg.close()
    fdm.close()
    f.close()
    fds.close()

def qmmolmain(imn, cwd, usrdir, qmjob_prefix, qmmol_job, nqm, nlink, cln):
    """
    
    // Function which combines the functions in this file for execution of a Molpro job. //
    // It will prepare the input file, run the Molpro job, and then extract the results from the output. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.
    cwd : string
        The current working directory.
    usrdir : string
        The user directory.
    qmjob_prefix : string
        A prefix used to label the QM job input file.
    qmmol_job : string
        The path to the Molpro program.
    nqm : integer
        Number of QM atoms.
    nlink : integer
        Number of link atoms.
    cln : integer
        The QoMMMa cycle number.

    """
    
    # The files from the previous Molpro run are rearranged and renamed with the prefix 'old_'.
    if os.path.exists(cwd + ('%s%d'%('/image', imn)) + ('%s%s%d%s'%('/', qmjob_prefix, imn, '.in'))):
        try:
            shutil.copy(('%s%d%s'%(qmjob_prefix,imn, '.in')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '.in'))) 
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '.out')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '.out')))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '.in'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '.out'))
        except:
            qomend('ERROR, while rearrangeing previous cycle molpro files for image : ' + str(imn), cwd, usrdir)
     
    # The lattice data file required for Molpro is initialised.
    try:
        latdatin(imn)
    except:
        qomend('Error while creating lattice data file for image : ' + str(imn), cwd, usrdir)
        
    # The Molpro input file is created.      
    try:
        molinp(imn, cwd, qmjob_prefix, nqm, nlink)
    except:
        qomend('Error while creating molpro input file for image : ' + str(imn), cwd, usrdir)
        
    # The Molpro job is performed.       
    try:
        os.system(qmmol_job + ' '+('%s%d%s'%(qmjob_prefix, imn, '.in')))
    except:
        qomend('Error while running Molpro job at cycle:' + str(cln) + ' for image :' + str(imn), cwd, usrdir)
    
    # The results from the Molpro job are extracted and rearranged.        
    try:
        fi = '%s%d%s'%(qmjob_prefix, imn, '.out')
        molout(fi, imn, nqm, nlink, cwd)
        shutil.copy(('%s%d'%('ab_initio', imn)), cwd)
        shutil.copy(('%s%d'%('mulliken', imn)), cwd)
        shutil.copy(('%s%d%s'%('qmlatgrad', imn, '.out')), cwd)
        os.remove('%s%d'%('ab_initio', imn))
        os.remove('%s%d'%('mulliken', imn))
        os.remove('%s%d%s'%('qmlatgrad', imn, '.out'))
    except:
        qomend('ERROR, problem in reading Energy or Gradient or Mulliken charge from QM output file of image : ' + str(imn), cwd, usrdir)    

def latgradmerg(imn):
    """
    
    // Function which merges two lattice point charge files calculated for two states when running a MECP calculation. //
    // This function is called in the function mecp_molmain at each QoMMMa cycle. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.

    """
    
    # The lattice file for state A is copied and set as the 'main' lattice file.
    shutil.copy(('%s%d%s'%('qmlatgrad', imn, '_A.out')), ('%s%d%s'%('qmlatgrad', imn, '.out')))
    
    # Both lattice files for both states A and B are opened.
    f = open(('%s%d%s'%('qmlatgrad',imn, '_B.out')), 'r')
    fd = open(('%s%d%s'%('qmlatgrad', imn, '.out')), 'a')
    
    # The data found in the lattice file for state B is written to the 'main' lattice file.
    # Thus, the files have been merged.
    for line in f:
        fd.write(line)
      
    # Files are closed and old files are deleted.
    f.close()
    fd.close()
    os.remove('%s%d%s'%('qmlatgrad', imn, '_A.out'))
    os.remove('%s%d%s'%('qmlatgrad', imn, '_B.out'))

def mecp_molinp(imn, cwd, qmjob_prefix, nqm, nlink):
    """
    
    // Function which creates the inputs file required for the Molpro jobs for MECP calculations. //
    // This function is called in the function mecp_molmain at each QoMMMa cycle. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.
    cwd : string
        The current working directory.
    qmjob_prefix : string
        A prefix used to label the QM job input file.
    nqm : integer
        Number of QM atoms.
    nlink : integer
        Number of link atoms.

    """
        
    # The Molpro input file is created for the image.
    # This operation is performed for both states A and B.
    fda = open(('%s%d%s'%(qmjob_prefix, imn, '_A.in')), 'w')  
    fdb = open(('%s%d%s'%(qmjob_prefix, imn, '_B.in')), 'w')  
    
    # The relevant file paths are written to the Molpro input file.
    # These operations are performed on both states A and B.
    intg = cwd + '/image' + str(imn) + ('%s%s%d%s'%('/', qmjob_prefix, imn, '_A.intg'))
    nintg = cwd + '/image' + str(imn) + ('%s%s%d%s'%('/new_', qmjob_prefix, imn, '_A.intg'))
    fda.write('file,2,' + nintg)
    fda.write('\n') 
    fda.write('file,3,' + intg)
    fda.write('\n') 
    intg = cwd + '/image' + str(imn) + ('%s%s%d%s'%('/', qmjob_prefix, imn, '_B.intg'))
    nintg = cwd + '/image' + str(imn) + ('%s%s%d%s'%('/new_', qmjob_prefix, imn, '_B.intg'))
    fdb.write('file,2,' + nintg)
    fdb.write('\n') 
    fdb.write('file,3,' + intg)
    fdb.write('\n') 
    
    # The file qmheader is used to write header details to the input file.
    # This operation is performed for both states A and B.
    f = open((cwd + '/qmheader'), 'r')
    for line in f:
        fda.write(line)
        fdb.write(line)
    f.close()
    
    # The total number of atoms is written to the input file.
    # This operation is performed for both states A and B.
    ntot = int(nqm) + int(nlink)
    fda.write(str(ntot))
    fda.write('\n')
    fda.write('\n')
    fdb.write(str(ntot))
    fdb.write('\n')
    fdb.write('\n')
    
    # The cartesian coordinates of the QM region are written to the input file.
    # This operation is performed for both states A and B.
    f = open(('%s%d%s'%('qmgeom', imn, '.xyz')), 'r') 
    for line in f:
        fda.write(line)
        fdb.write(line)
    f.close()
    fda.write('}')
    fda.write('\n')
    fdb.write('}')
    fdb.write('\n')
    
    # The point charges and lattice gradient file names are written to the input file.
    # This operation is performed for both states A and B.
    latinp = '%s%d%s'%('lat', imn, '.dat')
    latout = '%s%d%s'%('qmlatgrad', imn, '_A.out')
    latline = 'lattice' + ' ' + '''\'''' + latinp + '''\'''' + ' ' + '''\'''' + latout + '''\''''
    fda.write(latline)
    fda.write('\n')
    latout = '%s%d%s'%('qmlatgrad', imn, '_B.out')
    latline = 'lattice' + ' ' + '''\'''' + latinp + '''\'''' + ' ' + '''\'''' + latout + '''\''''
    fdb.write(latline)
    fdb.write('\n')
    
    # The file qmmol_footer is used to write footer details to the input file. 
    # This operation is performed for both states A and B.
    f = open((cwd + '/qmmol_footer_A'), 'r')
    for line in f:
        fda.write(line)
    f.close()
    f = open((cwd + '/qmmol_footer_B'), 'r')
    for line in f:
        fdb.write(line)
    f.close()
    fda.close() 
    fdb.close() 

def mecp_molmain(imn, cwd, usrdir, qmjob_prefix, qmmol_job, nqm, nlink, cln):
    """
    
    // Function which combines the functions in this file for execution of Molpro jobs for MECP calculations. //
    // It will prepare the input files, run the Molpro jobs, and then extract the results from the outputs. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.
    cwd : string
        The current working directory.
    usrdir : string
        The user directory.
    qmjob_prefix : string
        A prefix used to label the QM job input file.
    qmmol_job : string
        The path to the Molpro program.
    nqm : integer
        Number of QM atoms.
    nlink : integer
        Number of link atoms.
    cln : integer
        The QoMMMa cycle number.

    """
    
    # The files from the previous Molpro runs are rearranged and renamed with the prefix 'old_'.
    # This operation is performed for both states A and B.    
    if os.path.exists(cwd + ('%s%d'%('/image', imn)) + ('%s%s%d%s'%('/', qmjob_prefix, imn, '_A.in'))):
        try:
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_A.in')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_A.in'))) 
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_A.out')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_A.out')))
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_A.log')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_A.log')))
            shutil.copy(('%s%s%d%s'%('new_', qmjob_prefix, imn, '_A.intg')), ('%s%d%s'%(qmjob_prefix, imn, '_A.intg')))
            os.remove('%s%s%d%s'%('new_', qmjob_prefix, imn, '_A.intg'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_A.in'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_A.out'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_A.log'))
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_B.in')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_B.in'))) 
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_B.out')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_B.out')))
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_B.log')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_B.log')))
            shutil.copy(('%s%s%d%s'%('new_', qmjob_prefix, imn, '_B.intg')), ('%s%d%s'%(qmjob_prefix, imn, '_B.intg')))
            os.remove('%s%s%d%s'%('new_', qmjob_prefix, imn, '_B.intg'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_B.in'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_B.out'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_B.log'))
        except:
            qomend('ERROR, while rearranging previous cycle molpro files for image : ' + str(imn), cwd, usrdir)
            
    # The lattice data file required for Molpro is initialised.       
    try:
        latdatin(imn)
    except:
        qomend('Error while creating lattice data file for image : ' + str(imn), cwd, usrdir)
        
    # The Molpro input files are created for both states A and B.  
    try:
        mecp_molinp(imn, cwd, qmjob_prefix, nqm, nlink)
    except:
        qomend('Error while creating molpro input file for image : ' + str(imn), cwd, usrdir)
    
    # The Molpro job for state A is performed.    
    try:
        os.system(qmmol_job + ' ' + ('%s%d%s'%(qmjob_prefix, imn, '_A.in')))
    except:
        qomend('Error while running Molpro job for state A at cycle:' + str(cln) + ' for image :' + str(imn), cwd, usrdir)
        
    # The Molpro job for state B is performed.         
    try:
        os.system(qmmol_job + ' ' + ('%s%d%s'%(qmjob_prefix, imn, '_B.in')))
    except:
        qomend('Error while running Molpro job for state B at cycle:' + str(cln) + ' for image :' + str(imn), cwd, usrdir)
      
    # The results from the Molpro jobs are extracted, lattice files are merged, and files are rearranged.   
    # These operations are performed for both states A and B.        
    try:
        fi = '%s%d%s'%(qmjob_prefix, imn, '_A.out')
        molout(fi, imn, nqm, nlink, cwd)	
        fi = '%s%d%s'%(qmjob_prefix, imn, '_B.out')
        molout(fi, imn, nqm, nlink, cwd)	
        latgradmerg(imn)
        shutil.copy(('%s%d'%('ab_initio', imn)), cwd)
        shutil.copy(('%s%d'%('mulliken', imn)), cwd)
        shutil.copy(('%s%d%s'%('qmlatgrad', imn, '.out')), cwd)
        os.remove('%s%d'%('ab_initio', imn))
        os.remove('%s%d'%('mulliken', imn))
        os.remove('%s%d%s'%('qmlatgrad', imn, '.out'))
    except:
        qomend('ERROR, problem in reading Energy or Gradient or Mulliken charge from QM output file of image : ' + str(imn), cwd, usrdir)    

