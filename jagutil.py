#!/usr/bin/python3

"""
// This is a helper QoMMMa Python file, which contains the functions used in execution of a Jaguar job. //
"""

# Global imports.
import os
import shutil

# Local imports.
from qomutil import qomend     
 
def atomic():
    """
    
    // Function which creates the file atomic_selection required for proper execution of Jaguar jobs. //
    // This function is called only once in the functiob qminitial found in qommma.py. //
    
    Arguments
    ----------
    NONE

    """
    
    # The new file atomic_selection is generate from information found in atomic_prelim.
    # Both files are opened/created.
    fi = open('atomic_prelim', 'r')
    fd = open('atomic_section', 'w')          
    
    # Using a for-loop, relevant information is extracted from atomic_prelim and written to atomic_selection.
    ll = 0
    fd.write('&atomic')
    fd.write('\n')
    fd.write('atom   vdw')
    fd.write('\n')
    for line in fi:
        ll = ll + 1
        fd.write('%s%d%s' % (line.strip(), ll, '   0.1'))
        fd.write('\n')
    fd.write('&')
    
    # Files are closed and old files are deleted.
    fd.close()
    fi.close()
    os.remove('atomic_prelim')

def jaginp(imn, cwd, qmjob_prefix):
    """
    
    // Function which creates the input file required for a Jaguar job. //
    // This function is called in the function qmjagmain at each QoMMMa cycle. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.
    cwd : string
        The current working directory.
    qmjob_prefix : string
        A prefix used to label the QM job input file.

    """
    
    # If using the nudged elastic band, the directory for the image is initialised.
    cwd1 = cwd + '%s%d'%('/image', imn)
    
    # The Jaguar input file is created for the image.
    fd = open(('%s%d%s'%(qmjob_prefix, imn, '.in')), 'w')  
    
    # The details in the .pts file are written to the input file.
    pts = 'GPTSFILE:' + cwd1 + ('%s%d%s'%('/points', imn, '.pts'))
    fd.write(pts)
    fd.write('\n')
    
    # The file qmheader is used to write header details to the input file.    
    f = open((cwd + '/qmheader'), 'r')
    for line in f:
        fd.write(line)
    f.close()
    fd.write('\n')
    
    # The cartesian coordinates of the QM region are written to the input file.    
    f = open(('%s%d%s'%('qmgeom', imn, '.xyz')), 'r') 
    for line in f:
        fd.write(line)
    f.close()
    fd.write('&')
    fd.write('\n')
    
    # The details in the file atomic_section (generated by the function atomic() in this file) are written to the input file.
    f = open((cwd + '/atomic_section'), 'r')
    for line in f:
        fd.write(line)
    f.close()
    fd.write('\n')
    
    # The point charge array is written to the input file.
    f = open(('%s%d%s'%('charges', imn, '.xyz')), 'r') 
    for line in f:
        fd.write(line)
    f.close()
    
    # If the file containing the guess orbitals is found, then they are written to the input file.
    try:
        f = open(('%s%d'%('orbs', imn)), 'r') 
        for line in f:
            fd.write(line)
        f.close()
    except: 
        pass
    fd.close()

def jagout(fi, l, nqm, nlink):
    """
    
    // Function which extracts the energy, forces and Mulliken charges from a Molpro output file. //
    
    Arguments
    ----------
    fi : string
        Jaguar job output file name.
    l : integer
        If using the nudged elastic band, this is the image number.
    nqm : integer
        Number of QM atoms.
    nlink : integer
        Number of link atoms.

    """
    
    # The output file containing QM energy and gradients is created.
    fd = open(('%s%d'%('ab_initio', l)), 'a')
    fd.write('Energy')
    fd.write('\n')
    
    # The output file containing QM Mulliken charges is created.
    fdm = open(('%s%d'%('mulliken', l)), 'a')
    
    # The Jaguar output file is opened.    
    f = open(fi, 'r')
    
    # While loop iterates through the whole Jaguar output file.   
    while 1:
        line = f.readline()
        if not line:break
        
        # The self energy of the charges is saved which represents the electrostatic interaction between point charges.
        if line[:37] == '   (D)    Point charge-point charge..':
            pointE = float(line.split()[4])
        
        # Once the SCF is done, the energy is extracted, and the true energy is calculated by subtracting the point charge energy from the SCF energy.
        # This energy is written to the file ab_initio*.
        elif line[:37] == '   (N)  Total energy.................':
            totE = float(line.split()[3])
            ene = totE - pointE 
            fd.write(str(ene))
            fd.write('\n')
        
        # The gradients corresponding to each cartesian coordinate are extracted from the output file.
        # This gradient is written to the file ab_initio*.
        elif line[:32] == '  forces (hartrees/bohr) : total': 
            fd.write('Gradient')
            fd.write('\n')
            f.readline()
            f.readline()
            f.readline()
            for i in range(nqm + nlink):
                line = f.readline().split()
                fd.write(line[0].rjust(3))
                linex = float(line[2]) * -1
                fd.write(str(linex).rjust(20))
                liney = float(line[3]) * -1
                fd.write(str(liney).rjust(20))
                linez = float(line[4]) * -1
                fd.write(str(linez).rjust(20))
                fd.write('\n')  
            fd.close()
        
        # The Mulliken charges are extracted from the output file.
        # These Mulliken charges and the total charge are written to the file mulliken*.
        elif line[:51] == '  Atomic charges from Mulliken population analysis:':
            ntot = nqm + nlink
            nx = ntot / 5
            
            # The if statement deals with the situation of (nqm + nlink) < 5.
            if nx == 0:
                f.readline()
                f.readline()
                line = f.readline()
                ll = 0
                for i in range(ntot):
                    ll = ll + 1
                    fdm.write(line.split()[ll].rjust(10))
                    fdm.write('\n')  
                f.readline()
                line = f.readline()
                fdm.write('total charge')
                fdm.write('\n') 
                fdm.write(line[26:])
                
            # The else condition deals with the situation of (nqm + nlink) >= 5.
            else:
                for i in range(nx):
                    f.readline()
                    f.readline()
                    line = f.readline()
                    ll = 0
                    for i in range(5):
                        ll = ll + 1
                        fdm.write(line.split()[ll].rjust(10))
                        fdm.write('\n')
                    nny = ntot - (nx * 5)
                if nny > 0:        
                    f.readline()
                    f.readline()
                    line = f.readline()
                    ll = 0
                    for i in range(nny):
                        ll = ll + 1
                        fdm.write(line.split()[ll].rjust(10))
                        fdm.write('\n')
                f.readline()
                line = f.readline()
                fdm.write('total charge')
                fdm.write('\n') 
                fdm.write(line[26:])
            fdm.close()
    f.close()

def latgrad(f, im, nqm, nlink):
    """
    
    // Function which calculates the gradient from the electrostatic potential obtained from the Jaguar calculation. //
    
    Arguments
    ----------
    fi : string
        Jaguar *.resp output file name.
    l : integer
        If using the nudged elastic band, this is the image number.
    nqm : integer
        Number of QM atoms.
    nlink : integer
        Number of link atoms.

    """
    
    # The Jaguar .resp file is opened.
    fil = open(f, 'r')
    
    # The file containing point charges is opened.
    ftc = open('%s%d%s'%('points_chg', im, '.pts'), 'r')
    
    # The output gradient file is opened.
    fg = open('%s%d%s'%('qmlatgrad', im, '.out'), 'a')
    
    # Point charges are all added to the list cha.
    cha=[]
    for line in ftc:
        tcha = float(line.split()[0])
        cha.append(tcha)
    ftc.close()
    
    # Lines which do not need to be read are parsed.
    fil.readline().split()
    for k in range(nqm + nlink):
        fil.readline()
        
    # Total number of point charges is written to qmlatgrad*.out.
    fg.write(' gradient output')
    fg.write('\n')
    fg.write(str(len(cha)))
    fg.write('\n')
    
    # The gradient is calculated by a simple numerical expression.
    for ik in range(len(cha)):
        j = 0
        for jk in range(3):
            j = j + 1
            line1 = fil.readline().split()
            line2 = fil.readline().split()
            grad = float(cha[ik]) * (float(line1[0]) - float(line2[0])) / (float(line1[j]) - float(line2[j]))
            fg.write(str(grad).rjust(25))
        fg.write('\n')
    fg.close()
    fil.close()

def orbsread(fi, fs):
    """
    
    // Function which reads orbs from jagjob.01.in to create the file orbs, which will be used in Jaguar input. //
    
    Arguments
    ----------
    fi : string
        Input file name.
    fs : string
        Output file name.

    """
    
    # Both input and output files are opened.
    fd = open(fs, 'w')
    f = open(fi, 'r')
    
    # The input file is read and appropriate lines are written to the output file.
    while 1:
        line = f.readline()
        if not line:break
        if line[:6] == '&guess':
            fd.write(line)
            while 1:
                line = f.readline()
                fd.write(line)
                if line[0] == '&':
                    break
    f.close()
    fd.close()

def qmjagmain(imn, cwd, usrdir, qmjob_prefix, qmjag_job, nqm, nlink, cln):
    """
    
    // Function which combines the functions in this file for execution of a Jaguar job. //
    // It will prepare the input file, run the Jaguar job, and then extract the results from the output. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.
    cwd : string
        The current working directory.
    usrdir : string
        The user directory.
    qmjob_prefix : string
        A prefix used to label the QM job input file.
    qmjag_job : string
        The path to the Jaguar program.
    nqm : integer
        Number of QM atoms.
    nlink : integer
        Number of link atoms.
    cln : integer
        The QoMMMa cycle number.

    """
    
    # The files from the previous Jaguar run are rearranged and renamed with the prefix 'old_'.
    if os.path.exists(cwd + ('%s%d'%('/image', imn)) + ('%s%s%d%s'%('/', qmjob_prefix, imn, '.in'))):
        try:
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '.in')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '.in'))) 
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '.out')), ('%s%s%d%s'%('old_', qmjob_prefix,imn,'.out')))
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '.log')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '.log')))
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '.01.in')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '.01.in')))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '.01.in'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '.in'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '.log'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '.out')) 
        except:
            qomend('ERROR, while rearrangeing previous cycle jaguar files for image : ' + str(imn), cwd, usrdir)
     
    # The Jaguar input file is created.            
    try: 				
        jaginp(imn, cwd, qmjob_prefix)
    except:
        qomend('Error while creating jaguar input for image : ' + str(imn), cwd, usrdir)
        
    # The Jaguar job is performed.          
    try:
        os.system(qmjag_job + ' ' + ('%s%d%s'%(qmjob_prefix, imn, '.in')))
    except:
        qomend('Error while running Jagjob at cycle: ' + str(cln) + ' image :' + str(imn), cwd, usrdir)
    
    # The results from the Jaguar job are extracted and rearranged.     
    try:
        fi = '%s%d%s'%(qmjob_prefix, imn, '.out')
        jagout(fi, imn, nqm, nlink)
        shutil.copy(('%s%d'%('ab_initio', imn)), cwd)
        shutil.copy(('%s%d'%('mulliken', imn)), cwd)
        os.remove('%s%d'%('ab_initio', imn))
        os.remove('%s%d'%('mulliken', imn))
    except:
        qomend('ERROR, problem in reading Energy or Gradient or Mulliken charge from QM output file of image : ' + str(imn), cwd, usrdir)  
     
    # The gradients are calculated, results extracted and rearranged.
    try:
        f = '%s%d%s'%(qmjob_prefix, imn, '.resp')
        latgrad(f, imn, nqm, nlink)
        shutil.copy(('%s%d%s'%('qmlatgrad', imn, '.out')), cwd) 
        shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '.resp')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '.resp')))
        os.remove('%s%d%s'%('qmlatgrad', imn, '.out'))
        os.remove('%s%d%s'%(qmjob_prefix, imn, '.resp'))
    except:
        qomend('ERROR, problem while calculating latice gradients from jaguar resp file for image : ' + str(imn), cwd, usrdir) 
     
    # The file orbs is created.   
    try:
       fio = '%s%d%s'%(qmjob_prefix, imn, '.01.in')
       fs = '%s%d'%('orbs', imn)
       orbsread(fio, fs) 
    except:
       qomend('ERROR, problem in reading orbs from ' + fio, cwd, usrdir)

def mjag_initial(jag_head, qmkey, cha_mul1, cha_mul2):
    """
    
    // Function which prepares the Jaguar input header for MECP calculations. //
    
    Arguments
    ----------
    jag_head : string
        Contains the details for assigning memory and number of processors for a QM job.
    qmkey : string
        Can either be None or the user input level of theory.
    cha_mul1 : list
        The charge and multiplicity for state A given in the format of a list of two numbers (i.e., cha_mul = [0,1]).
    cha_mul2 : list
        The charge and multiplicity for state B given in the format of a list of two numbers (i.e., cha_mul = [0,1]).

    """
    
    # Both header files are created.
    fda = open('qmheader_A', 'w')
    fdb = open('qmheader_B', 'w') 
    
    # The variable jag_head is written to the header files, which contains details for assigning memory and processors.
    fda.write(jag_head.lstrip())
    fdb.write(jag_head.lstrip())
    if qmkey != 'None':
        fda.write(qmkey.lstrip())
        fdb.write(qmkey.lstrip())
    
    # The charge and multiplicity of the system is written to the header files.
    fda.write(cha_mul1.lstrip())
    fdb.write(cha_mul2.lstrip())
    
    # Some final formatting details are written to the header files.
    fda.write('&')
    fdb.write('&')
    fda.write('\n')
    fdb.write('\n')
    fda.write('&zmat')
    fdb.write('&zmat')
    fda.close()
    fdb.close()

def mjaginp(imn, cwd, qmjob_prefix):
    """
    
    // Function which creates the input files required for the Jaguar jobs for MECP calculations. //
    // This function is called in the function mecp_jagmain at each QoMMMa cycle. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.
    cwd : string
        The current working directory.
    qmjob_prefix : string
        A prefix used to label the QM job input file.

    """
    
    # If using the nudged elastic band, the directory for the image is initialised.
    cwd1 = cwd + '%s%d'%('/image', imn)
    
    # The Jaguar input file is created for the image.
    # This operation is performed for both states A and B.
    fda = open(('%s%d%s'%(qmjob_prefix, imn, '_A.in')), 'w')  
    fdb = open(('%s%d%s'%(qmjob_prefix, imn, '_B.in')), 'w')
    
    # The details in the .pts file are written to the input file.
    # This operation is performed for both states A and B.
    pts = 'GPTSFILE:' + cwd1 + ('%s%d%s'%('/points', imn, '.pts'))
    fda.write(pts)
    fda.write('\n')
    fda.write('\n')
    fdb.write(pts)
    fdb.write('\n')
    fdb.write('\n')
    
    # The files qmheader_A and qmheader_B (generated by the function mjag_initial()) are used to write header details to the input files for states A and B.   
    fa = open((cwd + '/qmheader_A'), 'r')
    for line in fa:
        fda.write(line)
    fa.close()
    fda.write('\n')
    fb = open((cwd + '/qmheader_B'), 'r')
    for line in fb:
        fdb.write(line)
    fb.close()
    fdb.write('\n')
    
    # The cartesian coordinates of the QM region are written to the input file.      
    # This operation is performed for both states A and B.
    f = open(('%s%d%s'%('qmgeom', imn, '.xyz')), 'r') 
    for line in f:
        fda.write(line)
        fdb.write(line)
    f.close()
    fda.write('&')
    fda.write('\n')
    fdb.write('&')
    fdb.write('\n')

    # The details in the file atomic_section (generated by the function atomic() in this file) are written to the input file.    
    # This operation is performed for both states A and B.
    f=open((cwd+'/atomic_section'),'r')
    for line in f:
        fda.write(line)
        fdb.write(line)
    f.close()
    fda.write('\n')
    fdb.write('\n')
    
    # The point charge array is written to the input file.
    # This operation is performed for both states A and B.
    f = open(('%s%d%s'%('charges', imn, '.xyz')), 'r') 
    for line in f:
        fda.write(line)
        fdb.write(line)
    f.close()
   
    # If the files containing the guess orbitals is found, then they are written to the input files for states A and B.
    try:
        f = open(('%s%d'%('orbsA', imn)), 'r') 
        for line in f:
            fda.write(line)
        f.close()
    except: 
        pass
    try:
        f = open(('%s%d'%('orbsB', imn)), 'r') 
        for line in f:
            fdb.write(line)
        f.close()
    except: 
        pass
    fda.close()
    fdb.close()

def mecp_jagmain(imn, cwd, usrdir, qmjob_prefix,jjob,nqm,nlink,cln):
    """
    
    // Function which combines the functions in this file for execution of Jaguar jobs for MECP calculations. //
    // It will prepare the input files, run the Jaguar jobs, and then extract the results from the outputs. //
    
    Arguments
    ----------
    imn : integer
        If using the nudged elastic band, this is the image number.
    cwd : string
        The current working directory.
    usrdir : string
        The user directory.
    qmjob_prefix : string
        A prefix used to label the QM job input file.
    jjob : string
        The path to the Jaguar program.
    nqm : integer
        Number of QM atoms.
    nlink : integer
        Number of link atoms.
    cln : integer
        The QoMMMa cycle number.

    """

    # The files from the previous Jaguar run are rearranged and renamed with the prefix 'old_'.    
    # This operation is performed for both states A and B.    
    if os.path.exists(cwd + ('%s%d'%('/image', imn)) + ('%s%s%d%s'%('/', qmjob_prefix, imn, '_A.in'))):
        try:
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_A.in')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_A.in'))) 
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_A.out')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_A.out')))
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_A.log')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_A.log')))
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_A.01.in')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_A.01.in')))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_A.01.in'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_A.in'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_A.log'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_A.out')) 
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_B.in')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_B.in'))) 
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_B.out')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_B.out')))
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_B.log')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_B.log')))
            shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_B.01.in')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_B.01.in')))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_B.01.in'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_B.in'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_B.log'))
            os.remove('%s%d%s'%(qmjob_prefix, imn, '_B.out')) 
        except:
            qomend('error while rearrangeing Jaguar files created in previous run at cycle :' + str(cln) + ' for image: ' + str(imn), cwd, usrdir)
            
    # The Jaguar input files are created for both states A and B.              
    try:
        mjaginp(imn, cwd, qmjob_prefix)
    except:
        qomend('Error while trying to prepare Jaguar input files at cycle : ' + str(cln) + ' for image : ' + str(imn), cwd, usrdir)
    
    # The Gaussian job for state A is performed.           
    try:
        os.system(jjob + ' ' + ('%s%d%s'%(qmjob_prefix, imn, '_A.in')))
    except:
        qomend('Error while trying to run Jaguar job for First state at cycle : ' + str(cln) + ' for image : ' + str(imn), cwd, usrdir)

    # The Gaussian job for state B is performed.
    try:
        os.system(jjob + ' ' + ('%s%d%s'%(qmjob_prefix, imn, '_B.in')))
    except:
        qomend('Error while trying to run jaguar job for Second state at cycle : ' + str(cln) + ' for image: ' + str(imn), cwd, usrdir)
      
    # The results from the Jaguar job are extracted and rearranged.   
    # These operations are performed for both states A and B.        
    try:
        fi = '%s%d%s'%(qmjob_prefix, imn, '_A.out')
        jagout(fi, imn, nqm, nlink)
        fi = '%s%d%s'%(qmjob_prefix, imn, '_B.out')
        jagout(fi, imn, nqm, nlink)
        shutil.copy(('%s%d'%('ab_initio', imn)), cwd)
        shutil.copy(('%s%d'%('mulliken', imn)), cwd)
        os.remove('%s%d'%('ab_initio', imn))
        os.remove('%s%d'%('mulliken', imn))
    except:
        qomend('Problem while collecting results from Jaguar job at cycle :' + str(cln) + ' for image: ' + str(imn), cwd, usrdir)
    
    # The gradients are calculated, results extracted and rearranged.  
    # These operations are performed for both states A and B. 
    try:
        f = '%s%d%s'%(qmjob_prefix, imn, '_A.resp')
        latgrad(f, imn, nqm, nlink)
        shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_A.resp')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_A.resp')))
        os.remove('%s%d%s'%(qmjob_prefix, imn, '_A.resp'))
        f = '%s%d%s'%(qmjob_prefix, imn, '_B.resp')
        latgrad(f, imn, nqm, nlink)
        shutil.copy(('%s%d%s'%('qmlatgrad', imn, '.out')), cwd) 
        os.remove('%s%d%s'%('qmlatgrad', imn, '.out'))
        shutil.copy(('%s%d%s'%(qmjob_prefix, imn, '_B.resp')), ('%s%s%d%s'%('old_', qmjob_prefix, imn, '_B.resp')))
        os.remove('%s%d%s'%(qmjob_prefix, imn, '_B.resp'))
    except:
        qomend('Problem while calculating lattice gradient from Jaguar resp file at cycle :' + str(cln) + ' for image: ' + str(imn), cwd, usrdir)
        
    # The file orbs is created.    
    # These operations are performed for both states A and B.        
    try:
        fi = '%s%d%s'%(qmjob_prefix, imn, '_A.01.in')
        fs = '%s%d'%('orbsA', imn)
        orbsread(fi, fs)
        fi = '%s%d%s'%(qmjob_prefix, imn, '_B.01.in')
        fs = '%s%d'%('orbsB', imn)
        orbsread(fi, fs)
    except:
        qomend('Problem while collecting orbs from Jaguar file at cycle :' + str(cln) + ' for image: ' + str(imn), cwd, usrdir)