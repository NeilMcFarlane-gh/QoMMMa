MODULE dlc_constraint
use nrtype ; use coordinates ; use optimdata ; use math
implicit none

contains


	subroutine gen_cons(n_cons, n_prims, cdat, prim_list, prims)
	! Here, the constraint vectors are generated.
	!
	! ARGUMENTS:    n_cons      : Integer which represents the total number of constraints
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               cdat        : 2D array containing the details of each constraint.
	!               prim_list   : 2D array containing the details of each primitive internal coordinate in the form ([1,2],[2,3], etc..).
	!               prims       : 1D array containing all the primitive internal coordinates associated with this input.

	implicit none
	integer(i4b) :: i, j, n_cons, n_prims, prim_list(n_prims, 4)
	integer(i4b) :: temp_cons(4), temp_prim(4)
	real(dp) :: prims(n_prims)
	real(dp), allocatable :: cdat(:,:)
	
	! First, allocate cdat based on the number of primitive constraints.
	if (ALLOCATED(cdat)) deallocate(cdat)
	allocate(cdat(n_cons,n_prims))
	cdat = 0.0

	! By simple comparison of prim_list and the constrained primtives, we can obtain the integer corresponding to each constraint to add to cdat.
	do i=1, n_cons
		temp_cons = cnsat_p(i,:)
		do j=1, n_prims
			temp_prim = prim_list(j,:)
			if (MAXVAL(ABS(temp_cons - temp_prim)) .eq. 0) then
				cdat(i,j) = prims(j)
			end if
		end do
	end do

	end subroutine gen_cons
	

	subroutine proj_cons(atom_num, n_dlc, n_cons, n_prims, cdat, cdat_unproj, Umat)
	! Here, the vectors in cdat are projected onto the active DLC subspace such that they can be later isolated.
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_dlc       : Integer which represents the number of delocalised internal coordinates (by definition, 3N-6).
	!               n_cons      : Integer which represents the total number of constraints
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               cdat        : 2D array containing the details of each constraint.
	!							  After this subroutine, each of the constraint vectors have been projected into active DLC subspace.
	!               Umat        : 2D array containing the eigenvectors with eigenvalues greater than zero. 
	!                             This is the DLC transformation vector set.
	
	implicit none
	integer(i4b) :: atom_num, n_dlc, n_cons, n_prims, ic, ip, j
	real(dp) :: cdat(n_cons, n_prims), Umat(n_dlc, n_prims)
	real(dp) :: temp_cons(n_prims), temp_U(n_prims), work(n_prims)
	real(dp), allocatable :: cdat_unproj(:,:)

	! Save the unprojected cdat so that it can later be used, and zero out cdat so that it can be projected.
	if (ALLOCATED(cdat_unproj)) deallocate(cdat_unproj)
	allocate(cdat_unproj(n_cons,n_prims))
	cdat_unproj(:,:) = cdat(:,:)
	
	! First, start by performing the operation: dp_{ic,j} = <C_ic|U_j>
	do ic=1, n_cons
		do j=1, n_dlc
			work(j) = 0.0
			do ip = 1, n_prims
				work(j) = work(j) + Umat(j,ip)*cdat(ic,ip)
			end do
		end do

		! Lastly, perform the operation: C_ic = sum_j dp_{ic,j}*U_j
		do j=1, n_dlc
			do ip=1, n_prims
				cdat(ic,ip) = cdat(ic,ip) + work(j)*Umat(j,ip)
			end do
		end do
	end do

	end subroutine proj_cons


	subroutine gen_Vmat(atom_num, n_dlc, n_cons, n_prims, cdat, Umat, Vmat)
	! Here, the V matrix is generated by stacking of the projected constraint vector onto the active DLC subspace.
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_dlc       : Integer which represents the number of delocalised internal coordinates (by definition, 3N-6).
	!               n_cons      : Integer which represents the total number of constraints
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               cdat        : 2D array containing the projected constraints.
	!               Umat        : 2D array containing the eigenvectors with eigenvalues greater than zero. 
	!                             This is the DLC transformation vector set.
	!               Vmat        : 2D array containing the newly obtained V matrix which is the new active coordinate set + constraint vector.
	
	
	implicit none
	integer(i4b) :: atom_num, n_dlc, n_cons, n_prims, i, alloc_counter, cons_counter, U_counter
	real(dp) :: work(n_dlc), cdat(n_cons, n_prims), Umat(n_dlc, n_prims)
	real(dp), allocatable :: Vmat(:,:)
	
	! First, allocate Vmat appropriately.
	if (.not. ALLOCATED(Vmat)) allocate(Vmat((n_dlc + n_cons), n_prims))
	
	! The V matrix can be easily created. The constraint vector(s) are added first, followed by the original U matrix.
	alloc_counter = 1
	cons_counter = 1
	U_counter = 1
	do i=1, (n_dlc + n_cons)
		if (alloc_counter .le. n_cons) then
			Vmat(i,:) = cdat(cons_counter,:)
			alloc_counter = alloc_counter + 1
			cons_counter = cons_counter + 1
		else
			Vmat(i,:) = Umat(U_counter,:)
			alloc_counter = alloc_counter + 1
			U_counter = U_counter + 1
		end if
	end do
	
	end subroutine gen_Vmat
	
	
	subroutine ortho_mat(atom_num, n_dlc, n_cons, n_prims, Vmat)
	! Here, the V matrix is Gram-Schmidt orthogonalised.
	! The first vector taken in the procedure is the constraint vector(s), and the last vector should drop out as zero.
	! This leaves a 3N - 6 vector set containing the constraint vector(s) along with the active coordinate set.
	! This subroutine is shamelessly ripped from DL-FIND...
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_dlc       : Integer which represents the number of delocalised internal coordinates (by definition, 3N-6).
	!               n_cons      : Integer which represents the total number of constraints.
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               Vmat        : 2D array containing the V matrix which is the active coordinate set + constraint vector(s).
	!                             After this subroutine, the last vector in the V matrix should be all zero.
	
	implicit none
	integer(i4b) :: atom_num, n_dlc, n_cons, n_prims, i, j, k, nvec
	real(dp) :: work(n_prims), dnorm, scapro, tol, Vmat((n_dlc + n_cons), n_prims)
	real(dp), parameter :: tolerance = 1.0D-10

	! Start by initialising some values.
	nvec = n_dlc + n_cons
	
	! Now begin the loop of orthogonalisation of vectors i=2, nvec.
	do i=1, nvec
		work(:) = 0.0
		! Make the ith vector orthogonal to vectors k=1, i-1.
		do k=1, i-1
			scapro = 0.0D0
			do j=1, n_prims
				scapro = scapro + Vmat(i,j)*Vmat(k,j)
			end do
			do j=1, n_prims
				work(j) = work(j) + Vmat(k,j)*scapro
			end do
		end do

		! Now, subtract the collinear vector to make the ith vector orthogonal to k=1, i-1.
		do j=1, n_prims
			Vmat(i,j) = Vmat(i,j) - work(j)
		end do

		! Lastly, normalise the ith vector.
		dnorm = 0.0
		do j=1, n_prims
			dnorm = dnorm + Vmat(i,j)*Vmat(i,j)
		end do
		if (ABS(dnorm) < tolerance) then
			dnorm = 0.0D0
		else
			dnorm = 1.0D0 / SQRT(dnorm)
		end if
		do j = 1, n_prims
			Vmat(i,j) = Vmat(i,j)*dnorm
		end do
	end do

	end subroutine ortho_mat


	subroutine move_cons(atom_num, n_dlc, n_cons, n_prims, Vmat)
	! Here, the constraint vector(s) are moved behind the active space in Vmat and any zero vector(s) are dropped for the ease of working.
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_dlc       : Integer which represents the number of delocalised internal coordinates (by definition, 3N-6).	
	!               n_cons      : Integer which represents the total number of constraints.
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               Vmat        : 2D array containing the V matrix which is the active coordinate set + constraint vector(s).
	
	implicit none
	integer(i4b) :: atom_num, n_dlc, n_cons, n_prims, i
	real(dp) :: work((n_dlc + n_cons), n_prims)
	real(dp), allocatable :: Vmat(:,:)

	! Firstly, the V matrix is saved in work so that the V matrix can be appropriately deallocated and reallocated.
	work(:,:) = Vmat(:,:)
	
	! Now, the V matrix is deallocated and reallocated with appropriate dimensions.
	deallocate(Vmat)
	allocate(Vmat(n_dlc, n_prims))
	
	! The constraint(s) are now extracted from the working array and added to the back of the newly allocated Vmat.
	do i=1, n_cons
		Vmat((n_dlc - (i - 1)),:) = work(i,:)
	end do
	
	! Lastly, adding the active space to Vmat...
	do i=1, (n_dlc - n_cons)
		Vmat(i,:) = work(n_cons + i,:)
	end do

	end subroutine move_cons


	subroutine unproj_cons(atom_num, n_dlc, n_cons, n_prims, Vmat, cdat_unproj)
	! Here, the uprojected constraint vectors are added back to the V matrix in place of the projected ones.
	! This means that the coordinates can be more easily converted back to cartesians.
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_dlc       : Integer which represents the number of delocalised internal coordinates (by definition, 3N-6).
	!               n_cons      : Integer which represents the total number of constraints.
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               Vmat        : 2D array containing the V matrix which is the active coordinate set + constraint vector(s).
	!               cdat_unproj : 2D array containing the details of each constraint - unprojected!!
	
	implicit none
	integer(i4b) :: atom_num, n_dlc, n_cons, n_prims, i
	real(dp) :: Vmat(n_dlc, n_prims), cdat_unproj(n_cons, n_prims)
	
	! The unprojected constraint(s) are simply put back into Vmat.
	do i=1, n_cons
		Vmat((n_dlc - (i - 1)),:) = cdat_unproj(i,:)
	end do
	
	end subroutine unproj_cons
	

end module dlc_constraint