MODULE dlc_constraint
use nrtype ; use coordinates ; use optimdata ; use math
implicit none

contains


	subroutine gen_cons(n_cons, n_prims, cdat, prim_list)
	! Here, the constraint vectors are generated.
	!
	! ARGUMENTS:    n_cons      : Integer which represents the total number of constraints
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               cdat        : 2D array containing the details of each constraint.
	!               prim_list   : 2D array containing the details of each primitive internal coordinate in the form ([1,2],[2,3], etc..).

	implicit none
	integer(i4b) :: i, j, n_cons, n_prims, prim_list(n_prims, 4)
	integer(i4b) :: temp_cons(4), temp_prim(4)
	real(sp) :: cdat(n_cons, n_prims)

	! By simple comparison of prim_list and the constrained primtives, we can obtain the integer corresponding to each constraint to add to cdat.
	do i=1, n_cons
		temp_cons = cnsat_dlc(i,:)
		do j=1, n_prims
			temp_prim = prim_list(j,:)
			if (MAXVAL(temp_cons - temp_prim) .eq. 0) then
				cdat(i,j) = 1.0
			end if
		end do
	end do
	
	end subroutine gen_cons
	

	subroutine proj_cons(atom_num, n_cons, n_prims, cdat, Umat)
	! Here, the vectors in cdat are projected onto the active DLC subspace such that they can be later isolated.
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_cons      : Integer which represents the total number of constraints
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               cdat        : 2D array containing the details of each constraint.
	!							  After this subroutine, each of the constraint vectors have been projected into active DLC subspace.
	!               Umat        : 2D array containing the eigenvectors with eigenvalues greater than zero. 
	!                             This is the DLC transformation vector set.
	
	implicit none
	integer(i4b) :: atom_num, n_cons, n_prims, ic, ip, j
	real(sp) :: work((3 * atom_num) - 6), cdat(n_cons, n_prims), Umat(((3 * atom_num) - 6), n_prims)
	real(sp) :: cdat_unproj(n_cons, n_prims)

	! First, start by performing the operation: dp_{ic,j} = <C_ic|U_j>
	do ic=1, n_cons
		do j=1, SIZE(Umat,1)
			work(j) = 0.0
			do ip = 1, n_prims
				work(j) = work(j) + Umat(j,ip) * cdat(ip,ic)
			end do
		end do

		! Now, the unprojected cdat is saved so that the coordinate set can later be restored.
		cdat_unproj(:,:) = cdat(:,:)
		cdat(:,:) = 0.0

		! Lastly, perform the operation: C_ic = sum_j dp_{ic,j}*U_j
		do j=1, SIZE(Umat,1)
			do ip=1, n_prims
				cdat(ip,ic) = cdat(ip,ic) + work(j) * Umat(j,ip)
			end do
		end do
	end do

	end subroutine proj_cons


	subroutine gen_Vmat(atom_num, n_cons, n_prims, cdat, Umat, Vmat)
	! Here, the V matrix is generated by stacking of the projected constraint vector onto the active DLC subspace.
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_cons      : Integer which represents the total number of constraints
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               cdat        : 2D array containing the projected constraints.
	!               Umat        : 2D array containing the eigenvectors with eigenvalues greater than zero. 
	!                             This is the DLC transformation vector set.
	!               Vmat        : 2D array containing the newly obtained V matrix which is the new active coordinate set + constraint vector.
	
	
	implicit none
	integer(i4b) :: atom_num, n_cons, n_prims, i, alloc_counter, cons_counter, U_counter
	real(sp) :: work((3 * atom_num) - 6), cdat(n_cons, n_prims), Umat(((3 * atom_num) - 6), n_prims)
	real(sp), allocatable :: Vmat(:,:)
	
	! First, allocate Vmat appropriately.
	if (.not. ALLOCATED(Vmat)) allocate(Vmat((((3 * atom_num) - 6) + n_cons), n_prims))
	
	! Now, the V matrix can be easily created. The constraint vector(s) are added first, followed by the original U matrix.
	alloc_counter = 1
	cons_counter = 1
	U_counter = 1
	do i=1, SIZE(Vmat,1)
		if (alloc_counter .le. n_cons) then
			Vmat(i,:) = cdat(cons_counter,:)
			alloc_counter = alloc_counter + 1
			cons_counter = cons_counter + 1
		else
			Vmat(i,:) = Umat(U_counter,:)
			alloc_counter = alloc_counter + 1
			U_counter = U_counter + 1
		end if
	end do
	
	end subroutine gen_Vmat
	
	
	subroutine ortho_mat(atom_num, n_cons, n_prims, Vmat)
	! Here, the V matrix is Gram-Schmidt orthogonalised.
	! The first vector taken in the procedure is the constraint vector(s), and the last vector should drop out as zero.
	! This leaves a 3N - 6 vector set containing the constraint vector(s) along with the active coordinate set.
	! This subroutine is shamelessly ripped from DL-FIND...
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_cons      : Integer which represents the total number of constraints.
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               Vmat        : 2D array containing the V matrix which is the active coordinate set + constraint vector(s).
	!                             After this subroutine, the last vector in the V matrix should be all zero.
	
	implicit none
	integer(i4b) :: atom_num, n_cons, n_prims, i, j, k, nelem, nvec
	real(sp) :: work(n_prims), dnorm, scapro, tol, Vmat((((3 * atom_num) - 6) + n_cons), n_prims)
	real(sp), parameter :: tolerance = 1.0D-10

	! Start by initialising some values.
	nvec = ((3 * atom_num) - 6) + n_cons
	nelem = n_prims
	work = 0.0
	
	! begin, orthogonalise vectors i = 2,nvec
	do i = 1, nvec
		! make vector i orthogonal to vectors  k = 1,i-1
		do k = 1, i - 1
			scapro = 0.0D0
			do j = 1, nelem
				scapro = scapro + Vmat(i,j)*Vmat(k,j)
			end do
			do j = 1, nelem
				work(j) = work(j) + Vmat(k,j)*scapro
			end do
		end do

		! subtract the collinear vector to make vector i orthogonal to k = 1,i-1
		do j = 1, nelem
			Vmat(i,j) = Vmat(i,j) - work(j)
		end do

		! normalise vector i
		dnorm = 0.0
		do j = 1, nelem
			dnorm = dnorm + Vmat(i,j)*Vmat(i,j)
		end do
		if (ABS(dnorm) < tolerance) then
			dnorm = 0.0D0
		else
			dnorm = 1.0D0 / SQRT(dnorm)
		end if
		do j = 1, nelem
			Vmat(i,j) = Vmat(i,j)*dnorm
		end do
	end do

	end subroutine ortho_mat


	subroutine move_cons(atom_num, n_cons, n_prims, Vmat)
	! Here, the constraint vector(s) are moved behind the active space in Vmat and any zero vector(s) are dropped for the ease of working.
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_cons      : Integer which represents the total number of constraints.
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               Vmat        : 2D array containing the V matrix which is the active coordinate set + constraint vector(s).
	
	implicit none
	integer(i4b) :: atom_num, n_cons, n_prims, i
	real(sp) :: work((((3 * atom_num) - 6) + n_cons), n_prims)!, Vmat((((3 * atom_num) - 6) + n_cons), n_prims)
	real(sp), allocatable :: Vmat(:,:)

	! Firstly, the V matrix is saved in work so that the V matrix can be appropriately deallocated and reallocated.
	work(:,:) = Vmat(:,:)
	
	! Now, the V matrix is deallocated and reallocated with appropriate dimensions.
	deallocate(Vmat)
	allocate(Vmat(((3 * atom_num) - 6), n_prims))
	
	! The constraint(s) are now exracted from the working array and added to the back of the newly allocated Vmat.
	do i=1, n_cons
		if (i .eq. 1) then
			Vmat(((3 * atom_num) - 6),:) = work(n_cons,:)
		else
			Vmat(((3 * atom_num) - 6) - i,:) = work(n_cons - i,:)
		end if
	end do
	
	! Lastly, adding the active space to Vmat...
	do i=1, (((3 * atom_num) - 6) - n_cons)
		Vmat(i,:) = work(n_cons + i,:)
	end do

	end subroutine move_cons


	subroutine unproj_cons(atom_num, n_cons, n_prims, Vmat, cdat_unproj)
	! Here, the constraint vector(s) are moved behind the active space in Vmat and any zero vector(s) are dropped for the ease of working.
	!
	! ARGUMENTS:    atom_num    : Integer which represents the total number of atoms to be delocalised.
	!               n_cons      : Integer which represents the total number of constraints.
	!               n_prims     : Integer which represents the total number of primitive internal coordinates.
	!               Vmat        : 2D array containing the V matrix which is the active coordinate set + constraint vector(s).
	!               cdat        : 2D array containing the details of each constraint - unprojected!!
	
	implicit none
	integer(i4b) :: atom_num, n_cons, n_prims, i
	real(sp) :: Vmat(((3 * atom_num) - 6), n_prims), cdat_unproj(n_cons, n_prims)
	
	! The unprojected constraint(s) are simply put back into Vmat.
	do i=1, n_cons
		if (i .eq. 1) then
			Vmat(((3 * atom_num) - 6),:) = cdat_unproj(n_cons,:)
		else
			Vmat((((3 * atom_num) - 6) - i),:) = cdat_unproj(n_cons - i,:)
		end if
	end do

	end subroutine unproj_cons
	

end module dlc_constraint