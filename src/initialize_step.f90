SUBROUTINE initialize_step
use nrtype ; use coordinates ; use optimdata ; use primitive ; use math
implicit none

! Only used for GSM...
! In this subroutine, the step(s) associated with the constrained primitive internal coordinates given in qommma.in is/are taken.
! The useful thing is that within the Fortran code, both the double- and single-ended variants of GSM are the same.
! All the generation of primitive internal coordinate constraints is handled within the Python code.
! Overall, this leans up the Fortran code, and allows for easier manipulation of GSM-specific code.
!
! Practically speaking, the primitive internal coordinate constraints which were provided in qommma.in are converted to a format consistent with the primitive definitions.
! This means that the atom indices which were used are reset to start at 1 and are placed in numerical order (as is the case in initialize_prims).
! If a primitive driving coordinate (for SE-GSM) is provided which is not automatically generated by initialize_prims, then it is added to prim_list.
! This can happen in cases where a bond formation is being studied, as this will not be generated by initialize_prims.


integer(i4b) :: i, j, k, l, m, ii
integer(i4b) :: drive_temp, qm_temp, driving_work(ndriv,4), prim_list_work(nprim,4), to_add
integer(i4b) :: prim_temp1(4), prim_temp2(4)
real(sp) :: drive_coord(3), qm_coord(3), dq

if (ncon_prim .gt. 0) then
	! The first part is relatively simple. The coordinates in xopt are compared to the indices of the QM atoms.
	! After comparison, the numbers can simply be reset to their relative indice starting from 1.
	
	! First, get the QM region coordinates.
	do l=1, nq
		j = (3 * (l-1)) + 1
		k = (3 * (qm(l)-1)) + 1
		xq(j:j+2) = x(k:k+2)
	end do

	! Now, a series of loops and if-statements compares coordinates to generate the reordered driving coordinates.
	driving_work(:,:) = cnsat_p(:,:)
	do i=1, SIZE(driving_work,1)
		do j=1, 4
			drive_temp = driving_work(i,j)
			if (drive_temp .ne. 0) then
				k = (3 * (drive_temp-1)) + 1
				drive_coord = x(k:k+2)
				do l=1, nq
					qm_temp = qm(l)
					if (drive_temp .eq. qm_temp) then
						do m=1, nq
							ii = (3 * (m-1)) + 1
							qm_coord = xq(ii:ii+2)
							if (MAXVAL(drive_coord - qm_coord) .eq. 0) then
								driving_work(i,j) = l
							end if
						end do
					end if
				end do
			else 
				cycle
			end if
		end do
	end do	
	
	! If there are any primitive internal coordinates which were not automatically generated, then these are added to prim_list.
	! First the new version of prim_list must be allocated.
	prim_list_work = prim_list
	to_add = 0
	do i=1, SIZE(driving_work,1)
		prim_temp1 = driving_work(i,:)
		do j=1, SIZE(prim_list_work,1)
			prim_temp2 = prim_list_work(j,:)
			if (MAXVAL(prim_temp1 - prim_temp2) .eq. 0) then ! the primtive internal coordinate has already been generated so no need to add it.
				exit
			else if (j .eq. SIZE(prim_list_work,1)) then
				to_add = to_add + 1 ! we need to add a new one to prim_list.
			end if
		end do
	end do
	if (to_add .gt. 0) then
		nprim = nprim + to_add
		deallocate(prim_list)
		allocate(prim_list(nprim,4))
	end if
	
	! Now, the new primitives can be added to the array using the same method as above.
	to_add = 0
	do i=1, SIZE(prim_list_work,1)
		prim_list(i,:) = prim_list_work(i,:)
	end do
	do i=1, SIZE(driving_work,1)
		prim_temp1 = driving_work(i,:)
		do j=1, SIZE(prim_list_work,1)
			prim_temp2 = prim_list_work(j,:)
			if (MAXVAL(prim_temp1 - prim_temp2) .eq. 0) then
				exit
			else if (j .eq. SIZE(prim_list_work,1)) then
				to_add = to_add + 1
				prim_list((SIZE(prim_list_work,1) + to_add),:) = prim_temp1
			end if
		end do
	end do
	
	! Now that the primitive internal driving coordinates have been integrated into prim_list, the step can be taken along this coordinate.
	! If the constrained coordinate is to be kept fixed at its current value, then the value of dq is zero and nothing changes.
	call calc_prims(ndlc, SIZE(prim_list,1), prims, xq, prim_list)
	call gen_Bmat_prims(ndlc, SIZE(prim_list,1), xq, prim_list, Bmat_p)
	call prims_to_cart(ndlc, SIZE(prim_list,1), drive_dq, prims, xq, newx, Bmat_p, prim_list)	
	
end if	

end subroutine initialize_step