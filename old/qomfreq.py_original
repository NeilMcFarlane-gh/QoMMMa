#!/usr/bin/python
import os
import sys
import shutil
from time import asctime

"""This python program file consist of following modules used in QoMMMa frequency calculation, this program will be called from qmmm module in qommma.py if the user requests frequency job through job='Freq' keyword or from qommma main program qommma.py if maxcycle=0 or 1 and job='Freq'."""

def initial(nimg,cwd,qommmadir):
   '''This module is to setup the intial arrangements for frequency calculation; it will create a directory (freq*) for each image in image directories, it will run geom_expl module in qomutil with optimized coordinate file for each image. Then it will run QoMMMa setup program to get charges*.xyz and qmgeom*.xyz (Note, here QoMMMa setup program will use MM charges in Defaultcharges file, which was generated by the mmjob module (with job=initial) in QoMMMa main program in the begining of QoMMMa optimization). Then it will call addatmnum module in qomutil to add the atom numbers in to qmgeom*.xyz file. And then it will copy all necessary files to freq* directory. This module will be called only once from freqmain module. Here nimg is the integer giving number of images, cwd and qommmadir are string representing main working directory and QoMMMa directory, respectively.'''
   im=0
   for i in range(nimg):
     im=im+1
     fi='%s%d%s'%('geom',im,'.xyz')
     from qomutil import geom_expl      	# to get geom_expl*.xyz for all images
     geom_expl(fi,im)
     dst=cwd+('%s%d'%('/image',im))+('%s%d'%('/freq',im))
     os.mkdir(dst)
     shutil.copy(cwd+('%s%d%s'%('/geom',im,'.xyz')),dst+('%s%d%s'%('/geom',im,'.xyz')))  
     shutil.copy('geom1.key',dst+('/mgrad.key'))
   os.system(qommmadir+'/bin/setup8.x')     	# QoMMMa setup program
   im=0
   for i in range(nimg):
     im=im+1
     from qomutil import addatmnum		# to add atom numbers
     addatmnum(im)
     dst=cwd+('%s%d'%('/image',im))+('%s%d'%('/freq',im))
     shutil.copy(('%s%d%s'%('qmgeom',im,'.xyz')),dst+('%s%d%s' % ('/qmgeom',im,'.xyz')))
     shutil.copy(('%s%d%s'%('nqmgeom',im,'.xyz')),dst+('%s%d%s' % ('/nqmgeom',im,'.xyz')))
     shutil.copy(('%s%d%s'%('charges',im,'.xyz')),dst)
     os.remove('%s%d'%('report_header',im))
     os.remove('%s%d%s'%('charges',im,'.xyz'))
     os.remove('%s%d%s'%('qmgeom',im,'.xyz'))
     os.remove('%s%d%s'%('nqmgeom',im,'.xyz'))

def mminpco(im,qmlst,delq):
  '''This program generates the 2*3*nqm (where nqm is the number of qm atoms)  number of Tinker coordinate files to calculate the MM gradients used in frequency job. Here integer im is image number, qmlst is the array containg list of qm atoms and delq is the real constant used for finite differnce while generating coordinates. This module will be called from freqmain module for each image.'''  
  nqm=len(qmlst)
  fi=open(('%s%d%s'%('geom',im,'.xyz')),'r')
  n=int(fi.readline().split()[0])
  ii=0
  alabel={}
  aconect={}
  acoord={}
  for i in range(n):
    ii=ii+1
    line=fi.readline().split()
    alabel[ii]=line[1]
    acoord[((ii-1)*3)+1]=line[2]
    acoord[((ii-1)*3)+2]=line[3]
    acoord[((ii-1)*3)+3]=line[4]
    aconect[ii]=line[5:]
  fi.close()
  k=0
  sn=0
  irun=0
  while 1:
   k=k+1
   if k in qmlst:
     ancoord={}
     apcoord={}
     irun=irun+1
     ii=0
     for i in range(n):
       ii=ii+1 
       if k==ii:
         ik=0
         for il in range(3):
            ik=ik+1
            sn=sn+1 
            ancoord[((ii-1)*3)+1]=float(acoord[((ii-1)*3)+1])
            apcoord[((ii-1)*3)+1]=float(acoord[((ii-1)*3)+1])
            ancoord[((ii-1)*3)+2]=float(acoord[((ii-1)*3)+2])
            apcoord[((ii-1)*3)+2]=float(acoord[((ii-1)*3)+2])
            ancoord[((ii-1)*3)+3]=float(acoord[((ii-1)*3)+3])
            apcoord[((ii-1)*3)+3]=float(acoord[((ii-1)*3)+3])
            if ik==1:
              ancoord[((ii-1)*3)+1]=ancoord[((ii-1)*3)+1]-delq
              apcoord[((ii-1)*3)+1]=apcoord[((ii-1)*3)+1]+delq
            if ik==2:
              ancoord[((ii-1)*3)+2]=ancoord[((ii-1)*3)+2]-delq
              apcoord[((ii-1)*3)+2]=apcoord[((ii-1)*3)+2]+delq
            if ik==3:
              ancoord[((ii-1)*3)+3]=ancoord[((ii-1)*3)+3]-delq
              apcoord[((ii-1)*3)+3]=apcoord[((ii-1)*3)+3]+delq
            irem=n-ii
            iin=ii
            for ir in range(irem):
               iin=iin+1
               ancoord[((iin-1)*3)+1]=acoord[((iin-1)*3)+1]
               apcoord[((iin-1)*3)+1]=acoord[((iin-1)*3)+1]
               ancoord[((iin-1)*3)+2]=acoord[((iin-1)*3)+2]
               apcoord[((iin-1)*3)+2]=acoord[((iin-1)*3)+2]
               ancoord[((iin-1)*3)+3]=acoord[((iin-1)*3)+3]
               apcoord[((iin-1)*3)+3]=acoord[((iin-1)*3)+3]
            f='%s%d%s%d%s'%('mmgradco',im,'_qmn',sn,'.xyz')
            fn=open(f,'w')
            f1='%s%d%s%d%s'%('mmgradco',im,'_qmp',sn,'.xyz')
            fp=open(f1,'w')
            iir=0
            fn.write(str(n).rjust(6))
            fn.write('\n')
            fp.write(str(n).rjust(6))
            fp.write('\n')
            for ip in range(n):
               iir=iir+1
               fn.write(str(iir).rjust(6))
               fn.write(str(alabel[iir]).rjust(4))
               fn.write(str(ancoord[((iir-1)*3)+1]).rjust(12))
               fn.write(str(ancoord[((iir-1)*3)+2]).rjust(12))
               fn.write(str(ancoord[((iir-1)*3)+3]).rjust(12))
               for item in aconect[iir]: 
                  fn.write(item.rjust(6))
               fn.write('\n')
               fp.write(str(iir).rjust(6))
               fp.write(str(alabel[iir]).rjust(4))
               fp.write(str(apcoord[((iir-1)*3)+1]).rjust(12))
               fp.write(str(apcoord[((iir-1)*3)+2]).rjust(12))
               fp.write(str(apcoord[((iir-1)*3)+3]).rjust(12))
               for item in aconect[iir]: 
                  fp.write(item.rjust(6))
               fp.write('\n')
            fn.close()
            fp.close()
       else: 
           ancoord[((ii-1)*3)+1]=acoord[((ii-1)*3)+1]
           apcoord[((ii-1)*3)+1]=acoord[((ii-1)*3)+1]
           ancoord[((ii-1)*3)+2]=acoord[((ii-1)*3)+2]
           apcoord[((ii-1)*3)+2]=acoord[((ii-1)*3)+2]
           ancoord[((ii-1)*3)+3]=acoord[((ii-1)*3)+3]
           apcoord[((ii-1)*3)+3]=acoord[((ii-1)*3)+3]
   if irun==nqm:break

def analgrad(im,qmlst,qommmadir):
  '''This module is to run Tinker 'analyze_grad' job for all the structures generated by mminpco module. Here im is the integer representing image number, qmlst is the array of QM atoms list and qommmadir is the string representing QoMMMa program directory. This module will be called from freqmain module for each image.'''  
  nqm=len(qmlst)
  ii=0
  for i in range(nqm*3):
    ii=ii+1
    fip='%s%d%s%d%s'%('mmgradco',im,'_qmp',ii,'.xyz')
    shutil.copy(fip,'mgrad.xyz')
    fch=os.popen(qommmadir+'/bin/analyze_grad','w')	# MM gradient run
    fn='mgrad.xyz'
    fch.write(fn+'\nE\n')
    fch.close()
    shutil.copy('mm_grad',('%s%d%s%d'%('mmgrad',im,'_qmp',ii)))
    os.remove('mgrad.xyz')
    os.remove('mm_grad') 
    os.remove(fip)
    fin='%s%d%s%d%s'%('mmgradco',im,'_qmn',ii,'.xyz')
    shutil.copy(fin,'mgrad.xyz')
    fch=os.popen(qommmadir+'/bin/analyze_grad','w')	# MM gradient run
    fn='mgrad.xyz'
    fch.write(fn+'\nE\n')
    fch.close()
    shutil.copy('mm_grad',('%s%d%s%d'%('mmgrad',im,'_qmn',ii)))
    os.remove('mgrad.xyz')
    os.remove('mm_grad') 
    os.remove(fin)

def mmhes(im,qmlst,n,delq):
  '''This module is used to calculate the MM hessian from gradients calculated with analyze_grad Tinker job. And  then MM Hessian will be stored in to a file 'mmhes*' with specifc format. Here im is the integer representing image number, qmlst is the array containg QM atoms list, n is the integer giving total number of atoms and delq is the real constant used for finite differnce while generating coordinates. This module will be called from freqmain module for each image.''' 
  kcal_au=627.5095
  bo_ang=0.529177249
  nqm=int(len(qmlst))
  mhes=[[{} for i in range (nqm*3)] for i in range(nqm*3)]
  ii=0 
  for i in range(nqm*3):
    ii=ii+1
    fp='%s%d%s%d'%('mmgrad',im,'_qmp',ii)
    fn='%s%d%s%d'%('mmgrad',im,'_qmn',ii) 
    fip=open(fp,'r')
    fin=open(fn,'r')   
    fip.readline()
    fin.readline()
    iql=0
    mp=0
    for il in range(n):
       iql=iql+1
       linep=fip.readline().split()
       linen=fin.readline().split()
       if iql in qmlst:
          mp=mp+1
          mhes[ii-1][mp-1]=((float(linep[2])-float(linen[2]))/kcal_au/(2*delq)*bo_ang*bo_ang)
          mp=mp+1
          mhes[ii-1][mp-1]=((float(linep[3])-float(linen[3]))/kcal_au/(2*delq)*bo_ang*bo_ang)
          mp=mp+1
          mhes[ii-1][mp-1]=((float(linep[4])-float(linen[4]))/kcal_au/(2*delq)*bo_ang*bo_ang)
    fip.close()
    fin.close()
    os.remove(fp)
    os.remove(fn)
  for i in range(nqm*3):
     for j in range(nqm*3):
        mhes[i][j]=((mhes[i][j])+(mhes[j][i]))/2
        mhes[j][i]=mhes[i][j]
  fh=open(('%s%d'%('mmhes',im)),'w')
  indx=0
  for i in range(nqm*3):
     indx=indx+1
     hlp=0
     fh.write(str(indx).rjust(4))
     inum=0         
     for j in range(i+1):
        inum=inum+1
        hlp=hlp+1
        fh.write(str(mhes[i][j]).rjust(20))
        if hlp==4 and inum!=i+1:
          fh.write('\n')
          fh.write(str(indx).rjust(4))         
          hlp=0
     fh.write('\n')
  fh.close()

def freqinp(im,qmlst,cwd):
   '''This module is used to create an input file (hessian_input) for QoMMMa Frequency job (freq.x or prj_freq.x). This module will be called from freqmain module for each image. Here integers im representing image number and and qmlst is the array of QM atoms label. it uses nqmgeom*.xyz, qmhes* and mmhes* files for input.''' 
   nqm=len(qmlst)
   fh=open('hessian_input','w')
   fh.write('Number of QM atoms')
   fh.write('\n')
   fh.write(str(nqm))
   fh.write('\n')
   fh.write('Coordinates (in angstrom) of QM atoms')
   fh.write('\n')
   f=open('%s%d%s'%('nqmgeom',im,'.xyz'),'r')
   for i in range(nqm):
     line=f.readline()
     fh.write(line)
   f.close()
   fh.write('Total Hessian')
   fh.write('\n')
   fq=open('%s%d'%('qmhes',im,),'r')
   fm=open('%s%d'%('mmhes',im,),'r')
   while 1:
       lineq=fq.readline().split()
       if not lineq:break
       linem=fm.readline().split()
       if not linem:break
       fh.write(lineq[0].rjust(3))
       for i in range((len(lineq))-1): 
         res=float(lineq[i+1])+float(linem[i+1])
         fh.write(str(res).rjust(20))
       fh.write('\n')
   fm.close()
   fq.close()
   try:
    f=open(cwd+('%s%d'%('/gradients',im)),'r')
    fh.write('Total Gradient')
    fh.write('\n')
    f.readline()
    ln=0
    chk=0 
    while 1:
     line=f.readline()
     if not line:break   
     ln=ln+1
     if ln in qmlst:
       chk=chk+1
       fh.write(line)
     if chk==nqm:break
    f.close()
   except:pass
   fh.close()

def hescorrect(qhes,ntotqm,nqm,cwd,im):
  '''This program is used to correct QM hessian if link atom is inlcuded in the QoMMMa frequency calculation. This program is called from gauhesread (or molhesread or jaghesread) module. Here qhes containing 3*ntotqm number of hessian elements, ntotqm is total number of atoms used in QM input, nqm is the number of QM atoms, cwd is the string representing current working directory and integer im is the image number. this module will read 'link_details' file(generated by read_initfile.f90) in cwd to get label of QM atom which is connected with link atom and alpha value.''' 
  nlink=ntotqm-nqm 
  ff=open(cwd+'/link_details')
  qm_lk=[]						# QM atom connected with link atom
  alpha=[]
  alpha.append(0) 		
  for i in range(nlink):
     line=ff.readline().split()
     qm_lk.append(int(line[0]))
     alpha.append(float(line[1]))
  ff.close() 
  qmllab=[]        #label of Hessian corresponding to QM atom connected with link atom		
  qlh=[[] for i in range(1) for j in range(nlink+1)]
  k=0		        
  for item in qm_lk:
     hlp=(item*3)-3	
     k=k+1
     for i in range(3):
        qmllab.append(hlp+i+1)	
        qlh[k].append(hlp+i+1)  # this is useful to find alpha value 
  i=0
  for ir in range(nqm*3):
   i=i+1
   j=0
   for jr in range(ir+1):
     j=j+1 
     if i in qmllab:
        ip=qmllab.index(i)+1
        if j in qmllab:
           jp=qmllab.index(j)+1
           if i==j:
              rr=0
              for r in range(nlink):
                rr=rr+1
                if i in qlh[rr]:
                   const=alpha[rr]
              hlp=(1-const)*(1-const)*(float(qhes[nqm*3+ip][nqm*3+jp])) 
              qhes[i][j]=float(qhes[i][j])+(2*(1-const)*float(qhes[nqm*3+ip][j]))+hlp
           else:
             rr=0
             for r in range(nlink):
               rr=rr+1
               if i in qlh[rr]:
                  consti=alpha[rr]
               if j in qlh[rr]:
                  constj=alpha[rr]
             hlp=(1-consti)*(1-constj)*(float(qhes[nqm*3+ip][nqm*3+jp]))  
             qhes[i][j]=float(qhes[i][j])+(1-consti)*(float(qhes[nqm*3+ip][j]))+(1-constj)*(float(qhes[nqm*3+jp][i]))+hlp
        else:
            rr=0
            for r in range(nlink):
                rr=rr+1
                if i in qlh[rr]:
                   const=alpha[rr]
            qhes[i][j]=float(qhes[i][j])+((1-const)*float(qhes[nqm*3+ip][j]))
     elif j in qmllab:
         rr=0
         for r in range(nlink):
            rr=rr+1
            if j in qlh[rr]:
               const=alpha[rr]
         jp=qmllab.index(j)+1
         qhes[i][j]=float(qhes[i][j])+((1-const)*float(qhes[nqm*3+jp][i]))
  fh=open(('%s%d'%('qmhes',im)),'w')
  indx=0
  for i in range(nqm*3):
     indx=indx+1
     hlp=0
     fh.write(str(indx).rjust(4))
     inum=0         
     for j in range(i+1):
        inum=inum+1
        hlp=hlp+1
        fh.write(str(qhes[i+1][j+1]).rjust(20))
        if hlp==4 and inum!=i+1:
          fh.write('\n')
          fh.write(str(indx).rjust(4))         
          hlp=0
     fh.write('\n')
  fh.close()

def qmjaginp(im,qmkey,cwd,qmjob_prefix):
    '''This module is to generate Jaguar input file (qmjob_prefix*.in) for QM frequency calculation (if jaguar is used for QM calculation). This module will be called from freqmain module for each image. Here integer im representing image number, qmkey is the string containg qmkey given by user or None (set in default), cwd is the string containing path of main working directory and qmjob_prefix (string, prefix for QM job input file).'''
    fj=open(('%s%d%s'%(qmjob_prefix,im,'.in')),'w')
    fj.write('&gen')
    fj.write('\n')
    if qmkey.strip()!='None':
      fj.write(qmkey.lstrip())
    fj.write('ifreq=1')
    fj.write('\n')
    fj.write('&')
    fj.write('\n')
    fj.write('&zmat')
    fj.write('\n')
    f=open(('%s%d%s'%('qmgeom',im,'.xyz')),'r') 
    for line in f:
      fj.write(line)
    f.close()
    fj.write('&')
    fj.write('\n')
    f=open((cwd+'/atomic_section'),'r')
    for line in f:
      fj.write(line)
    f.close()
    fj.write('\n')
    f=open(('%s%d%s'%('charges',im,'.xyz')),'r') 
    for line in f:
      fj.write(line)
    f.close()
    fj.close() 

def jaghesread(im,ntotqm,nlink,cwd,qmjob_prefix):
   '''This module is to extract QM hessian from jaguar output file (qmjob_prefix*.01.in) and  then QM hessian will be stored in to a file 'qmhes*' with specifc format. TThis module will be called from freqmain module for each image. Here integer im represents image number, ntotqm is the total number of atoms in QM calculation (sum of nqm+nlink), nlink is the number of link atoms and cwd is the string representing current working directory. Here hescorrect module will be called if link atom(s) is used.'''
   f=open('%s%d%s'%(qmjob_prefix,im,'.01.in'),'r')
   qhes=[[] for i in range(ntotqm*3+1)]
   while 1:
      line=f.readline()
      if not line:break
      if line[:5]=='&hess':
        while 1:  
          line=f.readline().split()
          if not line:break
          if line=='&':break 
          if len(line)>=2:
            lline=len(line)
            place=(int(line[0]))
            for k in range(lline-1):
               qhes[place].append(line[k+1])
   f.close()
   for i in range(ntotqm*3):
     qhes[i+1].insert(0,[])
   nqm=ntotqm-nlink
   if nlink!=0:
        hescorrect(qhes,ntotqm,nqm,cwd,im)
   else:
     fh=open(('%s%d'%('qmhes',im)),'w')
     indx=0
     for i in range(nqm*3):
       indx=indx+1
       hlp=0
       fh.write(str(indx).rjust(4))
       inum=0         
       for j in range(i+1):
         inum=inum+1
         hlp=hlp+1
         fh.write(str(qhes[i+1][j+1]).rjust(20))
         if hlp==4 and inum!=i+1:
            fh.write('\n')
            fh.write(str(indx).rjust(4))         
            hlp=0
       fh.write('\n')
     fh.close()

def qmmolinp(im,qmkey,cwd,ntotqm,qmjob_prefix):
  '''This module is to generate molpro input file (qmjob_prefix*.in) for QM frequency calculation (if Molpro is used for QM calculation). This module will be called from freqmain module for each image. Here integer im representing image number, qmkey is the string containg qmkey given by user or None (set in default), cwd is the string containing path of main working directory and integer ntotqm is the total number of atoms in QM calculation (sum of nqm+nlink).'''
  fd=open(('%s%d%s'%(qmjob_prefix,im,'.in')),'w')
  f=open((cwd+'/qmheader'),'r')
  for line in f:
    fd.write(line)
  f.close()
  fd.write(str(ntotqm))
  fd.write('\n')
  fd.write('\n')
  f=open(('%s%d%s'%('qmgeom',im,'.xyz')),'r') 
  for line in f:
     fd.write(line)
  f.close()
  fd.write('}')
  fd.write('\n')
  latinp='%s%d%s'%('lat',im,'.dat')
  latout='%s%d%s'%('qmlatgrad',im,'.out')
  latline='lattice'+' '+'''\''''+latinp+'''\''''+' '+'''\''''+latout+'''\''''
  fd.write(latline)
  fd.write('\n')
  fd.write(qmkey.lstrip())
  fd.write('{Frequency;Print,Hessian}')
  fd.close()

def molhesread(im,ntotqm,nlink,cwd,qmjob_prefix):
   '''This module is to extract QM hessian from Molpro output file (qmjob_prefix*.out) and then QM hessian will be stored in to a file 'qmhes*' with specifc format. This module will be called from freqmain module for each image. Here integer im represents image number, ntotqm is the total number of atoms in QM calculation (sum of nqm+nlink), nlink is the number of link atoms and cwd is the string representing current working directory. Here hescorrect module will be called if link atom(s) is used.'''
   nqm=ntotqm-nlink
   f=open('%s%d%s'%(qmjob_prefix,im,'.out'),'r')
   qhes=[[] for i in range(ntotqm*3+1)]
   it=ntotqm*3 
   while 1:
     line=f.readline()
     if not line:break
     if line[:61]==' Force Constants (Second Derivatives of the Energy) in [a.u.]':
         f.readline()
         ll=0
         irun=1
         while 1:
           line=f.readline()
           ll=ll+1
           if len(line.strip())==0:break
           nline=line.split()
           lline=len(nline)
           for k in range(lline-1):
             if nline[0][1]=='X':
                ind=1
             if nline[0][1]=='Y':
                ind=2 
             if nline[0][1]=='Z':
                ind=3 
             place=(int(nline[0][2:])-1)*3+ind 
             qhes[place].append(nline[k+1])
           if ll==it:
                f.readline()
                ll=5*irun
                irun=irun+1
   f.close()
   for i in range(ntotqm*3):
     qhes[i+1].insert(0,[])
   if nlink!=0:
       hescorrect(qhes,ntotqm,nqm,cwd,im)
   else:
    fh=open(('%s%d'%('qmhes',im)),'w')
    indx=0
    for i in range(nqm*3):
      indx=indx+1
      hlp=0
      fh.write(str(indx).rjust(4))
      inum=0         
      for j in range(i+1):
        inum=inum+1
        hlp=hlp+1
        fh.write(str(qhes[i+1][j+1]).rjust(20))
        if hlp==4 and inum!=i+1:
          fh.write('\n')
          fh.write(str(indx).rjust(4))         
          hlp=0
      fh.write('\n')
    fh.close()

def qmgauinp(im,qmkey,cwd,cha_mul,extra_basis,gau_head,qmjob_prefix):
   '''This module is used to generate Gaussian input file (qmjob_prefix*.in) for QM frequency calculation (if Gaussian is used for QM calculation). This module will be called from freqmain module for each image. Here integer im representing image number, qmkey is the string containg qmkey given by user or None (set in default), cwd is the string containing path of main working directory and cha_mul is list of two numbers representing charge and multiplicity of QM region (default is [0,1]), extra_basis is user specified basis set as a string (default=None) and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'), qmjob_prefix (string, prefix for QM job input file).'''
   fd=open(('%s%d%s'%(qmjob_prefix,im,'.in')),'w')
   if gau_head.lower()!='none':
      fd.write(gau_head.strip())  
      fd.write('\n')
   cwd1=cwd+'%s%d'%('/image',im)+'%s%d'%('/freq',im)
   chk='%chk='+cwd1+('%s%s%d%s'%('/',qmjob_prefix,im,'.chk'))
   fd.write(chk)
   fd.write('\n')
   fd.write('\n')
   if qmkey.lower()!='none':
     if os.path.exists(cwd+'%s%d%s%s%d%s'%('/image',im,'/',qmjob_prefix,im,'.chk')):
          shutil.copy(cwd+'%s%d%s%s%d%s'%('/image',im,'/',qmjob_prefix,im,'.chk'),cwd1)
          jobkey='# '+qmkey+' Nosymm Guess=Read Charge Freq'
     else:
          jobkey='# '+qmkey+' Charge Nosymm Freq'
   else:
     if os.path.exists(cwd+'%s%d%s%s%d%s'%('/image',im,'/',qmjob_prefix,im,'.chk')):
          shutil.copy(cwd+'%s%d%s%s%d%s'%('/image',im,'/',qmjob_prefix,im,'.chk'),cwd1)
          jobkey='# Guess=Read Nosymm Charge Freq'
     else:
          jobkey='# Charge Nosymm Freq'
   fd.write(jobkey)
   fd.write('\n')
   fd.write('\n')
   fd.write('TITLE')
   fd.write('\n')
   fd.write('\n')
   fd.write(str(cha_mul[0]).rjust(3))  
   fd.write(str(cha_mul[1]).rjust(5))  
   fd.write('\n') 	  
   f=open(('%s%d%s'%('qmgeom',im,'.xyz')),'r') 
   for line in f:
     fd.write(line)
   f.close()
   fd.write('\n')
   if extra_basis.lower()!='none':
     fd.write(extra_basis.lstrip())
     fd.write('\n')
   f=open(('%s%d%s'%('charges',im,'.xyz')),'r') 
   for line in f:
     if line.strip() != '&pointch':
        if line.strip() !='&':
           line=line.split()
           fd.write(line[1].rjust(13))
           fd.write(line[2].rjust(13))
           fd.write(line[3].rjust(13))
           fd.write(line[0].rjust(10))
           fd.write('\n')
   f.close()
   fd.write('\n')
   fd.close()

def gauhesread(im,ntotqm,nlink,cwd,qmjob_prefix):
 '''This module is to extract QM hessian from Gaussian output file (qmjob_prefix*.log) and  then QM hessian will be stored in to a file 'qmhes*' with specifc format. This module will be called from freqmain module for each image. Here integer im and ntotqm representing image number and total qm atoms (including link atoms).  Here hescorrect module will be called if link atom(s) is used.'''
 f=open('%s%d%s'%(qmjob_prefix,im,'.log'),'r')
 while 1:
  line=f.readline()
  if not line:break
  if line[:23]==' Test job not archived.':
    line=f.readline()
    resl=line.strip()
    while 1:  
      line=f.readline()
      if not line:break
      resl=resl+line.strip()
 f.close()
 for i in range(len(resl)):
  if resl[i:i+5]=='NImag':
     res=resl[i+6:]
     break
 for i in range(len(res)):
   if res[i:i+1]=='\\':
     resl=res[i+2:]
     break
 res=resl.split(',')
 qhes=[[] for i in range(ntotqm*3+1)]
 ip=0
 for i in range(ntotqm*3):
   for j in range(i+1):
     if '\\' in res[ip]:
       hlp=res[ip]
       for k in range(len(res[ip])):
         if hlp[k:k+1]=='\\':
           res[ip]=hlp[:k-1]
     qhes[i+1].append(str(res[ip]))  
     ip=ip+1
 for i in range(ntotqm*3):
    qhes[i+1].insert(0,[])
 nqm=ntotqm-nlink
 if nlink!=0:
   hescorrect(qhes,ntotqm,nqm,cwd,im)
 else:
  fh=open(('%s%d'%('qmhes',im)),'w')
  indx=0
  for i in range(nqm*3):
     indx=indx+1
     hlp=0
     fh.write(str(indx).rjust(4))
     inum=0         
     for j in range(i+1):
        inum=inum+1
        hlp=hlp+1
        fh.write(str(qhes[i+1][j+1]).rjust(20))
        if hlp==4 and inum!=i+1:
          fh.write('\n')
          fh.write(str(indx).rjust(4))         
          hlp=0
     fh.write('\n')
  fh.close()

def freqmain(qommmadir,qmkey,qmc_job,usrdir,cha_mul,extra_basis,gau_head,prj_freq,qmjob_prefix,qmcode):
   '''This is main frequency job module. it uses qomend and qomlog routines are in qomutil (to print messages and to stop the QoMMMa program if there is any error), and latdatin module (if QM code is molpro) in molutil to generate lattice data file. To get number of atoms, QM and link atoms details it reads two files (fortinput, link_details) generated at initial QoMMMa setup. Here qommmadir and usrdir are string representing qommma and user directories, respectively, qmkey is string, either None (set in default) or user defined qmkey, qmc_job is the string  that containg full QM code path, cha_mul is list of two numbers representing charge and multiplicity (default is [0,1], used only for Gaussian job), extra_basis is user specified basis set as a string (default='None', used only for Gaussian job) and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None', used only for Gaussian job). prj_freq is used to request projected frequency calculation for a particular image, given as an array, defalut; prj_freq=[]. qmjob_prefix (string, prefix for QM job input and output files). qmcode is string representing QM code used. This module is called from main QoMMMa progem if user request frequency job through job='Freq' keyword. Here the parameter delq is need to be set for finite difference used in MM hessian job. After completion of frequency job for all images it will copy output files and all the QoMMMa job files to user directory and stop the program.'''
   from qomutil import qomend
   from qomutil import qomlog
   delq=0.0001			# for finite difference in MM hessian
   cwd=os.getcwd()
   f=open(cwd+'/fortinput','r')
   f.readline()
   line=f.readline().split()
   n=int(line[0])			# total no. of atoms
   nqm=int(line[1])			# no.of QM atoms
   nlink=int(line[2])			# no. of link atoms
   f.readline()
   f.readline()
   f.readline()
   nimg=int(f.readline().split()[0])	# no. of images
   f.readline()
   qmlst=[]				# QM atoms list
   for i in range(nqm):
       line=f.readline().split()
       qmlst.append(int(line[0]))
   f.close()
   ntotqm=nqm+nlink   
   if nlink > 1:
     ff=open(cwd+'/link_details')
     qm_lk=[]				# QM atom connected with link atom
     for i in range(nlink):
       line=ff.readline().split()
       qm_lk.append(int(line[0]))
     ff.close() 
     for i in range(nlink-1):
       j=i
       for k in range(nlink-1-i):  
         j+=1  
         if qm_lk[i]>qm_lk[j]:
          qomend('Error, link atoms details should be in increasing order with respect to QM atom number, In Link key give first details for link atom connected with QM atom '+str(qm_lk[j])+'  then for QM atom  '+str(qm_lk[i]),cwd,usrdir)
   try:
     initial(nimg,cwd,qommmadir)
   except:
     qomend('Error: Initial setup program for QoMMMa frequency job failed',cwd,usrdir) 
   im=0
   for i in range(nimg):
     im=im+1 
     qomlog('About to start MM Hessian calculation for QoMMMa Frequency job for image '+str(im),usrdir)
     dst=cwd+('%s%d'%('/image',im))+('%s%d'%('/freq',im))
     os.chdir(dst)
     try:
       mminpco(im,qmlst,delq)
     except:
       qomend('Error, while creating input geometry for mm gradient job for image : '+str(im),cwd,usrdir) 
     try:
       analgrad(im,qmlst,qommmadir)
     except:
       qomend('Error, while running mm gradient job for image : '+str(im),cwd,usrdir)
     try:
       mmhes(im,qmlst,n,delq)
     except:
       qomend('Error, while calculating mm hessian for image : '+str(im),cwd,usrdir)
     qomlog('About to start QM frequency calculation for image : '+str(im),usrdir)    
     try: 
      if qmcode.lower()=='jaguar':
         qmjaginp(im,qmkey,cwd,qmjob_prefix)
      elif qmcode.lower()=='gaussian': 
         qmgauinp(im,qmkey,cwd,cha_mul,extra_basis,gau_head,qmjob_prefix)
      elif qmcode.lower()=='molpro':
         from molutil import latdatin 
         latdatin(im) 
         qmmolinp(im,qmkey,cwd,ntotqm,qmjob_prefix)
     except:
         qomend('Error, while creating input file for QM job for image : '+str(im),cwd,usrdir)
     try:				# qm job
       os.system(qmc_job+' '+('%s%d%s'%(qmjob_prefix,im,'.in')))
     except:
       qomend('Error while running QM frequency job for image :'+str(im),cwd,usrdir)
     try:
       if qmcode.lower()=='jaguar':
          jaghesread(im,ntotqm,nlink,cwd,qmjob_prefix)
       elif qmcode.lower()=='gaussian':
          gauhesread(im,ntotqm,nlink,cwd,qmjob_prefix)
       else:
          molhesread(im,ntotqm,nlink,cwd,qmjob_prefix)
     except:
          qomend('Error while reading QM hessian from QM output for image :'+str(im),cwd,usrdir)
     try:
         freqinp(im,qmlst,cwd)
     except:
         qomend('Error while preparing hessian_input for image :'+str(im),cwd,usrdir)
     if im in prj_freq:
         qomlog('Note, For image '+str(im)+ 'projected frequency calculation is requested',usrdir)
         try:		# QoMMMa projected Frequency program
            os.system(qommmadir+'/bin/prj_freq.x')     
         except:
            qomend('Error while running QoMMMa projected frequency program for image :'+str(im),cwd,usrdir)
     else:
         try:		# QoMMMa Frequency program
             os.system(qommmadir+'/bin/freq.x')     
         except:
             qomend('Error while running QoMMMa Frequency program for image :'+str(im),cwd,usrdir)
     try:
        shutil.copy('freqs.xyz',('%s%d%s'%('freqs',im,'.xyz')))  
        shutil.copy('freqs_results',('%s%d'%('freqs_results',im)))  
        os.remove('freqs.xyz')
        os.remove('freqs_results')
        shutil.copy(('%s%d%s'%('freqs',im,'.xyz')),usrdir+('%s%d%s'%('/freqs',im,'.xyz')))
        shutil.copy(('%s%d'%('freqs_results',im)),usrdir+('%s%d'%('/freqs_results',im)))
        os.chdir(cwd)
     except:
        qomend('Error in QoMMMa Frequency program for image :'+str(im),cwd,usrdir)
   qomend('Congratulations, Frequency job for all images completed',cwd,usrdir)
