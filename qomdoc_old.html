<!DOCTYPE html
PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
 <head>
  <title>QoMMMa programmers' manual</title>
  <link rel="stylesheet" type="text/css" href="qommma.css" />
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" />
<h1>QoMMMa programmers' manual</h1>
<h2>qommma_debug</h2>
<div>This is QoMMMa program version 8 writern in python. This program is to couple and run QM, MM and QoMMMa ForTran codes. It consist of following modules</div>
<h3>fortinp():</h3>
<div>This program is to create two input files; 'fortinput' this file contains all information to setup qmmm calculation, used in read_initfile.f90, and 'converg.data' file containing convergence criteria for QoMMMa optimization used in read_converg.f90. The input for this part is already readed from default and user input files. Input should be preovided through specific keywords.</div>
<h3>mmjob(mjob):</h3>
<div>This program is to create basic key files for Tinker job, creating image directories, checking number of input geometries, creating geom_expl*.xyz and to run Tinker analyze program to get initial charge. And  creating new geom*.key files from mm keys and inactive_list created by QoMMMa setup program.</div>
<h3>qminitial():</h3>
<div> This program creates the initial inputs for QM job, details were already readed from default and user input files.</div>
<h3>qmmm():</h3>
<div>This is the main QoMMMa program part, first it will execute MM program to get MM gradient, then it will prepare the input for QM program, runs the QM program and extracts the results from the QM run. Then QoMMMa optimization will begin. The convegence will be checked. Once convergence is achived it will move files to user directory and stops the QoMMMa program [or it will start the frequency calculation if the job='Freq' (default job='opt') using qomfreq program. If convergence is not achived the MM optimization will follow, then a postmicro job will create/rearrange the files to use for next QoMMMa cycle. This will continue until the convergence is achived or maxcycle.</div>
<h2>qomdoc</h2>
<div>This program is to generate QoMMMa manual (now you are reading !!!). it will generate either html or text document based on user's input while running this program. It consist of following sub-programs</div>
<h3>all_files(pattern,search_path,pathsep=os.pathsep):</h3>
<div>This module is used to search all available python file in directory given in search_path.</div>
<h3>docwrite(f,mode,fdoc):</h3>
<div>This program is to genarate documentation for each python file obtained from module all_files.</div>
<h2>gauutil</h2>
<div>This python program file is used to generate Gauusian input, to run </div>
<h3>gauinp(imn,cwd,qmjob_prefix,qmkey,cha_mul,extra_basis,gau_head):</h3>
<div>This routine is to prepare the input file for Gaussian job. It takes arguments: imn (integer, the image number); cwd (string, current working directory), qmjob_prefix (string, prefix for QM job input file), qmkey (string, either None or user given level of theory), cha_mul is the charge and multiplicity given as list of two numbers (default is cha_mul=[0,1]), extra_basis is user specified basis set as a string (default='None') and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This routine is called from qmgaumain routine for each cycle of QoMMMa.</div>
<h3>gauout(fi,l,nqm,nlink,fortf):</h3>
<div>This program is to extract energy, forces and Mulliken charges from Gaussian output. The arguments are: fi (string, Gaussian job output file name); l (integer, image number); nqm (integer, number of QM atoms); nlink (integer, number of link atoms). Gradients are calculated by multiplying forces with -1. Energy and gradients are stored in file ab_initio* and Mulliken charges is stored in file mulliken*. The gradients corresponding to MM point charges is calculated from electric field given in Gaussian support file (here file name is given as string 'fortf'), and are stored in a file 'qmlatgrad*.out'.</div>
<h3>qmgaumain(imn,cwd,usrdir,qmjob_prefix,qmgau_job,nqm,nlink,cln,qmkey,cha_mul,extra_basis,gau_head):</h3>
<div>This part of program is to prepare the input file, and then to run the Gaussian and to extract the results from output. It uses two subprograms (gauinp, gauout). It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), qmgau_job (is string, representing Gaussian path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number), qmkey (string, any extra keys specified by user for Gaussian job, default='None', i.e.'HF/STO-3G'), cha_mul is the charge and multiplicity given as list of two numbers (default is cha_mul=[0,1]), extra_basis is user specified basis set as a string (default='None'), and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This main routine is called from QoMMMa main program at each cycle. Before preparing new input files this routine will rename all Gaussian files created in previous cycle.</div>
<h3>mgauinp(imn,cwd,qmjob_prefix,qmkey,cha_mul1,cha_mul2,extra_basis,gau_head):</h3>
<div>This routine is to prepare the input file for Gaussian jobin MECP QoMMMa job. It will create two input files for two states A and B. It takes arguments: imn (integer, the image number); cwd (string, current working directory), qmjob_prefix (string, prefix for QM job input file), qmkey (string, either None or user given level of theory), cha_mul1 and cha_mul2 are the charge and multiplicity of states A and B, given as list, extra_basis is user specified basis set as a string (default='None') and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This routine is called from mecp_gaumain routine for each cycle of QoMMMa.</div>
<h3>mecp_gaumain(imn,cwd,usrdir,qmjob_prefix,qmgau_job,nqm,nlink,cln,qmkey,cha_mul1,cha_mul2,extra_basis,gau_head):</h3>
<div>This part of program is to prepare the input file, and then to run the Gaussian and to extract the results from output. It uses two subprograms (mgauinp, gauout). It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), qmgau_job (is string, representing Gaussian path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number), qmkey (string, any extra keys specified by user for Gaussian job, default='None', i.e.'HF/STO-3G'), cha_mul1 and cha_mul2 are the charge and multiplicity of two states in MECP, given as list of two numbers, extra_basis is user specified basis set as a string (default='None'), and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This main routine is called from QoMMMa main program at each cycle if MECP is requested. Before preparing new input files this routine will rename all Gaussian files created in previous cycle.</div>
<h2>gauutil_new</h2>
<div>This python program file is used to generate Gauusian input, to run </div>
<h3>gauinp(imn,cwd,qmjob_prefix,qmkey,cha_mul,extra_basis,gau_head):</h3>
<div>This routine is to prepare the input file for Gaussian job. It takes arguments: imn (integer, the image number); cwd (string, current working directory), qmjob_prefix (string, prefix for QM job input file), qmkey (string, either None or user given level of theory), cha_mul is the charge and multiplicity given as list of two numbers (default is cha_mul=[0,1]), extra_basis is user specified basis set as a string (default='None') and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This routine is called from qmgaumain routine for each cycle of QoMMMa.</div>
<h3>gauout(fi,l,nqm,nlink,fortf):</h3>
<div>This program is to extract energy, forces and Mulliken charges from Gaussian output. The arguments are: fi (string, Gaussian job output file name); l (integer, image number); nqm (integer, number of QM atoms); nlink (integer, number of link atoms). Gradients are calculated by multiplying forces with -1. Energy and gradients are stored in file ab_initio* and Mulliken charges is stored in file mulliken*. The gradients corresponding to MM point charges is calculated from electric field given in Gaussian support file (here file name is given as string 'fortf'), and are stored in a file 'qmlatgrad*.out'.</div>
<h3>qmgaumain(imn,cwd,usrdir,qmjob_prefix,qmgau_job,nqm,nlink,cln,qmkey,cha_mul,extra_basis,gau_head):</h3>
<div>This part of program is to prepare the input file, and then to run the Gaussian and to extract the results from output. It uses two subprograms (gauinp, gauout). It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), qmgau_job (is string, representing Gaussian path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number), qmkey (string, any extra keys specified by user for Gaussian job, default='None', i.e.'HF/STO-3G'), cha_mul is the charge and multiplicity given as list of two numbers (default is cha_mul=[0,1]), extra_basis is user specified basis set as a string (default='None'), and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This main routine is called from QoMMMa main program at each cycle. Before preparing new input files this routine will rename all Gaussian files created in previous cycle.</div>
<h3>mgauinp(imn,cwd,qmjob_prefix,qmkey,cha_mul1,cha_mul2,extra_basis,gau_head):</h3>
<div>This routine is to prepare the input file for Gaussian jobin MECP QoMMMa job. It will create two input files for two states A and B. It takes arguments: imn (integer, the image number); cwd (string, current working directory), qmjob_prefix (string, prefix for QM job input file), qmkey (string, either None or user given level of theory), cha_mul1 and cha_mul2 are the charge and multiplicity of states A and B, given as list, extra_basis is user specified basis set as a string (default='None') and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This routine is called from mecp_gaumain routine for each cycle of QoMMMa.</div>
<h3>mecp_gaumain(imn,cwd,usrdir,qmjob_prefix,qmgau_job,nqm,nlink,cln,qmkey,cha_mul1,cha_mul2,extra_basis,gau_head):</h3>
<div>This part of program is to prepare the input file, and then to run the Gaussian and to extract the results from output. It uses two subprograms (mgauinp, gauout). It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), qmgau_job (is string, representing Gaussian path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number), qmkey (string, any extra keys specified by user for Gaussian job, default='None', i.e.'HF/STO-3G'), cha_mul1 and cha_mul2 are the charge and multiplicity of two states in MECP, given as list of two numbers, extra_basis is user specified basis set as a string (default='None'), and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This main routine is called from QoMMMa main program at each cycle if MECP is requested. Before preparing new input files this routine will rename all Gaussian files created in previous cycle.</div>
<h2>jagutil</h2>
<div>This python program file is used to generate Jaguar input, to run the Jaguar job and to extract results from Jaguar output. It consists of the following routines.</div>
<h3>atomic():</h3>
<div>This routine is used to create a file 'atomic_section' (which sets the vdW radius for the QM atoms) used by Jaguar. This is called only once from the qminitial routine of the QoMMMa main program. it uses datas in 'atomic_prelim' file, which is generated by QoMMMa setup program.</div>
<h3>jaginp(imn,cwd,qmjob_prefix):</h3>
<div>This routine is to prepare the input file for Jaguar. It takes arguments: imn (integer, the image number); cwd (string, current working directory) and qmjob_prefix (string, prefix for QM job input file). This routine is called from qmjagmain routine for each cycle of QoMMMa.</div>
<h3>jagout(fi,l,nqm,nlink):</h3>
<div>This program is to extract energy, forces and Mulliken charges from Jaguar output. The arguments are: fi (string, jaguar output file name; l (integer, image number); nqm (integer, number of QM atoms); nlink (integer, number of link atoms). Gradients are obtained by multiplying forces with -1. Energy and gradients are stored in file ab_initio* and Mulliken charges is stored in file mulliken*.</div>
<h3>latgrad(f,im,nqm,nlink):</h3>
<div>This program is to calculate the gradient from electrostatic potential obtained from jaguar calculation. It reads the electrostatic potentials from *.resp file, it reads the point charges from charges*.xyz file. The output file, qmlatgrad*.out, format is as like Molpro lattice gradient output file format. Here f is jaguar resp file name (as a string), im, nqm, nlink are image number, number of qm and link atoms, respectively as an integer.</div>
<h3>orbsread(fi,fs):</h3>
<div>This part is to read orbs from jagjob.01.in to create a file orbs, which will be latter used in jaguar input. it takes two string arguments for input and output file names.</div>
<h3>qmjagmain(imn,cwd,usrdir,qmjob_prefix,qmjag_job,nqm,nlink,cln):</h3>
<div>This part of program is to prepare the input file, and then to run the jaguar and to extract the results from output. It uses three subprograms (jaginp, jagout, latgrad, orbsread) from jagutil. It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), qmjag_job (is string, representing Jaguar run path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number). This main routine is called from QoMMMa main program at each cycle. Before preparing new input file this routine will rename all Jaguar files created in previous cycle.</div>
<h3>mjag_initial(jag_head,qmkey,cha_mul1,cha_mul2):</h3>
<div>This routine is to prepare Jaguar input header to use Jaguar job if mecp job is requested. It takes following string arguments: jag_head (options for jaguar), qmkey (user specified QM options); cha_mul1 (charge and multiplicity of state 1), and cha_mul2 (charge and multiplicity of state 2) as a string. This program is called only once from main QoMMMa program through qminitial routine if MECP is requected in QoMMMa.</div>
<h3>mjaginp(imn,cwd,qmjob_prefix):</h3>
<div>This routine is to prepare the input file for Jaguar calculation in qommma_mecp . It takes arguments: imn (integer, the image number); cwd (string, current working directory) and qmjob_prefix (string, prefix for QM job input file). This routine is called from mecp_jagmain routine.</div>
<h3>mecp_jagmain(imn,cwd,usrdir,qmjob_prefix,jjob,nqm,nlink,cln):</h3>
<div>This is main part of program; to prepare the input file, and to run the jaguar and to extract the results from output. It uses four subprograms (mjaginp, jagout, latgrad, orbsread) from jagutil. It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), jjob (is string, representing Jaguar run path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number). This main routine is called from QoMMMa main program at each cycle if mecp is requested. Before preparing new input file this routine will rename all Jaguar files created in previous cycle.</div>
<h2>molutil</h2>
<div>This python program file is used to generate molpro input, run the molpro job and to extract results from molpro output. Here qomend module is imported from qomutil to print the error message and to stop the program if error occurs. It consist of following modules</div>
<h3>latdatin(imn):</h3>
<div>This module is to create the lattice point charge input file 'lat*.xyz' to use in Molpro, input for this program is obtained from charges*.xyz. It takes image number (integer) as the argument. This module will be called from qmmolmain module at cycel of QoMMMa.</div>
<h3>molinp(imn,cwd,qmjob_prefix,nqm,nlink):</h3>
<div>This module is to prepare the input file for Molpro, it gets the image number (imn, integer), cwd, string representing current working directory and qmjob_prefix (string, prefic for QM input and output files). nqm and nlink are integer representing number of QM and link atoms. This module is called from qmmolmain module for each cycle of QoMMMa.</div>
<h3>molout(fi,l,nqm,nlink,cwd):</h3>
<div>This program is to extract energy, forces and Mulliken charges from Molpro output. The arguments are: fi (string, Molpro output file name); l (integer, image number); nqm (integer, number of QM atoms); nlink (integer, number of link atoms); cwd (string, current working directory). Energy and gradients are stored in file ab_initio* and Mulliken charges is stored in file mulliken*.</div>
<h3>qmmolmain(imn,cwd,usrdir,qmjob_prefix,qmmol_job,nqm,nlink,cln):</h3>
<div>This part of program is to prepare the lattice data file, molpro input file, and then to run the Molpro and to extract the results from output. It uses three subprograms (latdatin, molinp, molout) from molutil.  This is called from QoMMMa main program if QM code is molpro. It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), qmmol_job (is string, representing Molpro path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number). Before preparing new input file this routine will rename all Molpro files created in previous cycle.</div>
<h3>latgradmerg(imn):</h3>
<div>This routine is used to merg two lattice gradient files cacluated for two states for MECP program. It takes image number (imn, integer) as the argument. This module is called from mecp_molmain. </div>
<h3>mecp_molinp(imn,cwd,qmjob_prefix,nqm,nlink):</h3>
<div>This module is to prepare Molpro input files for two states in MECP, it gets the image number (imn, integer), current working directory (cwd,string) and prefix for input file name (qmjob_prefix, string). nqm and nlink are integer representing number of QM and link atoms. This module is called from mecp_molmain module for each cycle of QoMMMa.</div>
<h3>mecp_molmain(imn,cwd,usrdir,qmjob_prefix,qmmol_job,nqm,nlink,cln):</h3>
<div>This part of program is to prepare the lattice data file, molpro input file, and to run the Molpro and to extract the results from output. It uses three subprograms (latdatin, mecp_molinp, molout) from molutil. This is called from QoMMMa main program if QM code is molpro and job is mecp. It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), qmmol_job (is string, representing Molpro path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number). Before preparing new input file this routine will rename all Molpro files created in previous cycle.</div>
<h2>qomutil</h2>
<div>This python program file consist of following utility modules used in QoMMMa program.</div>
<h3>qomlog(s,usrdir):</h3>
<div>This routine is used to write the progress or error message of the QoMMMa job in a file, QoMMMa8.log. Here s is the message to be written in QoMMMa8.log file, and usrdir is users directory path (both are given as a string).</div>
<h3>qomend(s,cwd,usrdir):</h3>
<div>This is routine is used to stop the QoMMMa program. s is the message, cwd and usrdir are current working directory and user directory, respectively (all are given as string).</div>
<h3>addatmnum(imn):</h3>
<div>This program is to add the atom numbers to the qm atoms, this is called from rearrange and setini modules in qomutil, it takes image number as integer (imn).</div>
<h3>rearrange(nimg,cwd,qmjob_prefix,cln):</h3>
<div>This program rearranges the files generated by QoMMMa and QM output to use in Micro-optimization and in next cycle QM job. And then renames the files in image directory as old_*. Files microgeom*.xyz and gradcorrection are used in micro-optimization. It takes arguments nimg (number of images, integr), cwd (current working directory,string), qmjob_prefix (QM input file prefix, string) and cln (QoMMMa cycle number as integer). This module will be called from qmmm module of main qommma program at each cycle of QoMMMa.</div>
<h3>postrearrange(nimg,cwd):</h3>
<div>This program is to rearrange the files after postmicro QoMMMa job. It takes the arguments nimg (number of images, integer) and cwd (current working directory, string). This module will be called from qmmm module of main qommma program at each cycle of QoMMMa.</div>
<h3>qomreport(nimg,usrdir,cwd,cln,qomout):</h3>
<div>This program is to add the new report, to check the convergence and if the convergence is achived it will create a dummy file with name 'convergence_ok'. Here, integer nimg representing number of images, qommmadir and usrdir are string representing qommma and user directories, respectively, cln is the integer representing QoMMMa cycle, qomout is string either 'deep' (to save QM results, geom.xyz and gradients at each cycle) or 'None' (default, it will save only last two (or one) cycle files). This module will be called from qmmm module of main qommma program at each cycle of QoMMMa.</div>
<h3>setini(cwd,nimg,usrdir):</h3>
<div>This program creates update_geom file and moves the initial files created by QoMMMa setup program to the image directories. This module takes the arguments, cwd (string, current working directory), nimg (integer, number of images) and usrdir (string, user directory path). This program is called only once from qommma main program.</div>
<h3>tinkercharge(qommmadir):</h3>
<div>This part of module is to run the tinker analyze program and to extract the initial charges from tinker output. it takes qommma base directory as the argument (string). It is called from mmjob module of qommma main program.</div>
<h3>geom_expl(f,l):</h3>
<div>This program is to create a coordinate file (geom_expl*.xyz) to use as a coordinate file  in QoMMMa optimization and setup program from normal tinker xyz file type. it takes file name as the string argument and image number as the integer. This module is called from mmjob and qmmm modules of qommma main program.</div>
<h3>qmread(kk,usrdir):</h3>
<div>This program is to generate QM atoms list. Here kk is list of integers or range of numbers (as a string, for example '5-10') as a python list and usrdir as the string representing user directory. It gets the atom name from geom1.xyz file. It will take first two characters or first character from tinker xyz file atom name. The list is written in to 'fortinput' file and QoMMMa8.log file (just to check). This module is called from fortinp module of main qommma program.</div>
<h3>hesopt_write(hesopt,usrdir):</h3>
<div>This program is to generate list of hessian optimized MM atoms. hesopt contains list of integers or range of numbers (two numbers separated by '-' and as a string). usrdir is the string representing user directory. The list is written in to 'fortinput' file. This module is called from fortinp module of main qommma program.</div>
<h3>link_write(link):</h3>
<div>This program is to generate details for link atoms. link contains details for each link atom as Python tuple format. The link details are written in to 'fortinput' file. This module is called from fortinp module of main qommma program. While writting link details in to fortinput file  if more than one link atoms presents it will check the order of link atom details and rearrange it as increasing order with respect to QM atom label (this is needed for frequency job).</div>
<h3>cons_write(cons,usrdir):</h3>
<div>This program is to generate constrain details. cons contains details for each constrain as Python tuple format.  usrdir is the string representing user directory. The constrain details are written in to 'fortinput' file. This module is called from fortinp module of main qommma program.</div>
<h3>newcha_write(newcha):</h3>
<div>This program is to generate list of MM atoms and newly assigned charge for them. newcha contains atom label and charge as Python tuple format.  The list is then written in to 'fortinput' file. This module is called from fortinp module of main qommma program.</div>
<h3>inprange(kk,job,usrdir):</h3>
<div>This program is to write the atom labels in fortinput file, if the atom labels are given as range (string). Used for ninact. it takes arguments, kk (range, two numbers separated by '-', for example 10-50, given as a string), job (string, purpose of this input), usrdir (string, user directory). This module is called only once from fortinp module of main qommma program.</div>
<h2>qomfreq</h2>
<div>This python program file consist of following modules used in QoMMMa frequency calculation, this program will be called from qmmm module in qommma.py if the user requests frequency job through job='Freq' keyword or from qommma main program qommma.py if maxcycle=0 or 1 and job='Freq'.</div>
<h3>initial(nimg,cwd,qommmadir):</h3>
<div>This module is to setup the intial arrangements for frequency calculation; it will create a directory (freq*) for each image in image directories, it will run geom_expl module in qomutil with optimized coordinate file for each image. Then it will run QoMMMa setup program to get charges*.xyz and qmgeom*.xyz (Note, here QoMMMa setup program will use MM charges in Defaultcharges file, which was generated by the mmjob module (with job=initial) in QoMMMa main program in the begining of QoMMMa optimization). Then it will call addatmnum module in qomutil to add the atom numbers in to qmgeom*.xyz file. And then it will copy all necessary files to freq* directory. This module will be called only once from freqmain module. Here nimg is the integer giving number of images, cwd and qommmadir are string representing main working directory and QoMMMa directory, respectively.</div>
<h3>mminpco(im,qmlst,delq):</h3>
<div>This program generates the 2*3*nqm (where nqm is the number of qm atoms)  number of Tinker coordinate files to calculate the MM gradients used in frequency job. Here integer im is image number, qmlst is the array containg list of qm atoms and delq is the real constant used for finite differnce while generating coordinates. This module will be called from freqmain module for each image.</div>
<h3>analgrad(im,qmlst,qommmadir):</h3>
<div>This module is to run Tinker 'analyze_grad' job for all the structures generated by mminpco module. Here im is the integer representing image number, qmlst is the array of QM atoms list and qommmadir is the string representing QoMMMa program directory. This module will be called from freqmain module for each image.</div>
<h3>mmhes(im,qmlst,n,delq):</h3>
<div>This module is used to calculate the MM hessian from gradients calculated with analyze_grad Tinker job. And  then MM Hessian will be stored in to a file 'mmhes*' with specifc format. Here im is the integer representing image number, qmlst is the array containg QM atoms list, n is the integer giving total number of atoms and delq is the real constant used for finite differnce while generating coordinates. This module will be called from freqmain module for each image.</div>
<h3>freqinp(im,qmlst,cwd):</h3>
<div>This module is used to create an input file (hessian_input) for QoMMMa Frequency job (freq.x or prj_freq.x). This module will be called from freqmain module for each image. Here integers im representing image number and and qmlst is the array of QM atoms label. it uses nqmgeom*.xyz, qmhes* and mmhes* files for input.</div>
<h3>hescorrect(qhes,ntotqm,nqm,cwd,im):</h3>
<div>This program is used to correct QM hessian if link atom is inlcuded in the QoMMMa frequency calculation. This program is called from gauhesread (or molhesread or jaghesread) module. Here qhes containing 3*ntotqm number of hessian elements, ntotqm is total number of atoms used in QM input, nqm is the number of QM atoms, cwd is the string representing current working directory and integer im is the image number. this module will read 'link_details' file(generated by read_initfile.f90) in cwd to get label of QM atom which is connected with link atom and alpha value.</div>
<h3>qmjaginp(im,qmkey,cwd,qmjob_prefix):</h3>
<div>This module is to generate Jaguar input file (qmjob_prefix*.in) for QM frequency calculation (if jaguar is used for QM calculation). This module will be called from freqmain module for each image. Here integer im representing image number, qmkey is the string containg qmkey given by user or None (set in default), cwd is the string containing path of main working directory and qmjob_prefix (string, prefix for QM job input file).</div>
<h3>jaghesread(im,ntotqm,nlink,cwd,qmjob_prefix):</h3>
<div>This module is to extract QM hessian from jaguar output file (qmjob_prefix*.01.in) and  then QM hessian will be stored in to a file 'qmhes*' with specifc format. TThis module will be called from freqmain module for each image. Here integer im represents image number, ntotqm is the total number of atoms in QM calculation (sum of nqm+nlink), nlink is the number of link atoms and cwd is the string representing current working directory. Here hescorrect module will be called if link atom(s) is used.</div>
<h3>qmmolinp(im,qmkey,cwd,ntotqm,qmjob_prefix):</h3>
<div>This module is to generate molpro input file (qmjob_prefix*.in) for QM frequency calculation (if Molpro is used for QM calculation). This module will be called from freqmain module for each image. Here integer im representing image number, qmkey is the string containg qmkey given by user or None (set in default), cwd is the string containing path of main working directory and integer ntotqm is the total number of atoms in QM calculation (sum of nqm+nlink).</div>
<h3>molhesread(im,ntotqm,nlink,cwd,qmjob_prefix):</h3>
<div>This module is to extract QM hessian from Molpro output file (qmjob_prefix*.out) and then QM hessian will be stored in to a file 'qmhes*' with specifc format. This module will be called from freqmain module for each image. Here integer im represents image number, ntotqm is the total number of atoms in QM calculation (sum of nqm+nlink), nlink is the number of link atoms and cwd is the string representing current working directory. Here hescorrect module will be called if link atom(s) is used.</div>
<h3>qmgauinp(im,qmkey,cwd,cha_mul,extra_basis,gau_head,qmjob_prefix):</h3>
<div>This module is used to generate Gaussian input file (qmjob_prefix*.in) for QM frequency calculation (if Gaussian is used for QM calculation). This module will be called from freqmain module for each image. Here integer im representing image number, qmkey is the string containg qmkey given by user or None (set in default), cwd is the string containing path of main working directory and cha_mul is list of two numbers representing charge and multiplicity of QM region (default is [0,1]), extra_basis is user specified basis set as a string (default=None) and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'), qmjob_prefix (string, prefix for QM job input file).</div>
<h3>gauhesread(im,ntotqm,nlink,cwd,qmjob_prefix):</h3>
<div>This module is to extract QM hessian from Gaussian output file (qmjob_prefix*.log) and  then QM hessian will be stored in to a file 'qmhes*' with specifc format. This module will be called from freqmain module for each image. Here integer im and ntotqm representing image number and total qm atoms (including link atoms).  Here hescorrect module will be called if link atom(s) is used.</div>
<h3>freqmain(qommmadir,qmkey,qmc_job,usrdir,cha_mul,extra_basis,gau_head,prj_freq,qmjob_prefix,qmcode):</h3>
<div>This is main frequency job module. it uses qomend and qomlog routines are in qomutil (to print messages and to stop the QoMMMa program if there is any error), and latdatin module (if QM code is molpro) in molutil to generate lattice data file. To get number of atoms, QM and link atoms details it reads two files (fortinput, link_details) generated at initial QoMMMa setup. Here qommmadir and usrdir are string representing qommma and user directories, respectively, qmkey is string, either None (set in default) or user defined qmkey, qmc_job is the string  that containg full QM code path, cha_mul is list of two numbers representing charge and multiplicity (default is [0,1], used only for Gaussian job), extra_basis is user specified basis set as a string (default='None', used only for Gaussian job) and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None', used only for Gaussian job). prj_freq is used to request projected frequency calculation for a particular image, given as an array, defalut; prj_freq=[]. qmjob_prefix (string, prefix for QM job input and output files). qmcode is string representing QM code used. This module is called from main QoMMMa progem if user request frequency job through job='Freq' keyword. Here the parameter delq is need to be set for finite difference used in MM hessian job. After completion of frequency job for all images it will copy output files and all the QoMMMa job files to user directory and stop the program.</div>
<h2>qommma</h2>
<div>This is QoMMMa program version 8 writern in python. This program is to couple and run QM, MM and QoMMMa ForTran codes. It consist of following modules</div>
<h3>fortinp():</h3>
<div>This program is to create two input files; 'fortinput' this file contains all information to setup qmmm calculation, used in read_initfile.f90, and 'converg.data' file containing convergence criteria for QoMMMa optimization used in read_converg.f90. The input for this part is already readed from default and user input files. Input should be preovided through specific keywords.</div>
<h3>mmjob(mjob):</h3>
<div>This program is to create basic key files for Tinker job, creating image directories, checking number of input geometries, creating geom_expl*.xyz and to run Tinker analyze program to get initial charge. And  creating new geom*.key files from mm keys and inactive_list created by QoMMMa setup program.</div>
<h3>qminitial():</h3>
<div> This program creates the initial inputs for QM job, details were already readed from default and user input files.</div>
<h3>qmmm():</h3>
<div>This is the main QoMMMa program part, first it will execute MM program to get MM gradient, then it will prepare the input for QM program, runs the QM program and extracts the results from the QM run. Then QoMMMa optimization will begin. The convegence will be checked. Once convergence is achived it will move files to user directory and stops the QoMMMa program [or it will start the frequency calculation if the job='Freq' (default job='opt') using qomfreq program. If convergence is not achived the MM optimization will follow, then a postmicro job will create/rearrange the files to use for next QoMMMa cycle. This will continue until the convergence is achived or maxcycle.</div>
<h2>gauutil_old</h2>
<div>This python program file is used to generate Gauusian input, to run </div>
<h3>gauinp(imn,cwd,qmjob_prefix,qmkey,cha_mul,extra_basis,gau_head):</h3>
<div>This routine is to prepare the input file for Gaussian job. It takes arguments: imn (integer, the image number); cwd (string, current working directory), qmjob_prefix (string, prefix for QM job input file), qmkey (string, either None or user given level of theory), cha_mul is the charge and multiplicity given as list of two numbers (default is cha_mul=[0,1]), extra_basis is user specified basis set as a string (default='None') and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This routine is called from qmgaumain routine for each cycle of QoMMMa.</div>
<h3>gauout(fi,l,nqm,nlink):</h3>
<div>This program is to extract energy, forces and Mulliken charges from Gaussian output. The arguments are: fi (string, Gaussian job output file name); l (integer, image number); nqm (integer, number of QM atoms); nlink (integer, number of link atoms). Gradients are calculated by multiplying forces with -1. Energy and gradients are stored in file ab_initio* and Mulliken charges is stored in file mulliken*. The gradients corresponding to MM point charges is calculated from electric field, and are stored in a file 'qmlatgrad*.out'.</div>
<h3>qmgaumain(imn,cwd,usrdir,qmjob_prefix,qmgau_job,nqm,nlink,cln,qmkey,cha_mul,extra_basis,gau_head):</h3>
<div>This part of program is to prepare the input file, and then to run the Gaussian and to extract the results from output. It uses two subprograms (gauinp, gauout). It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), qmgau_job (is string, representing Gaussian path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number), qmkey (string, any extra keys specified by user for Gaussian job, default='None', i.e.'HF/STO-3G'), cha_mul is the charge and multiplicity given as list of two numbers (default is cha_mul=[0,1]), extra_basis is user specified basis set as a string (default='None'), and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This main routine is called from QoMMMa main program at each cycle. Before preparing new input files this routine will rename all Gaussian files created in previous cycle.</div>
<h3>mgauinp(imn,cwd,qmjob_prefix,qmkey,cha_mul1,cha_mul2,extra_basis,gau_head):</h3>
<div>This routine is to prepare the input file for Gaussian jobin MECP QoMMMa job. It will create two input files for two states A and B. It takes arguments: imn (integer, the image number); cwd (string, current working directory), qmjob_prefix (string, prefix for QM job input file), qmkey (string, either None or user given level of theory), cha_mul1 and cha_mul2 are the charge and multiplicity of states A and B, given as list, extra_basis is user specified basis set as a string (default='None') and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This routine is called from mecp_gaumain routine for each cycle of QoMMMa.</div>
<h3>mecp_gaumain(imn,cwd,usrdir,qmjob_prefix,qmgau_job,nqm,nlink,cln,qmkey,cha_mul1,cha_mul2,extra_basis,gau_head):</h3>
<div>This part of program is to prepare the input file, and then to run the Gaussian and to extract the results from output. It uses two subprograms (mgauinp, gauout). It takes arguments: imn (integer, the image number); cwd, (string, current working directory), usrdir (string, user directory), qmjob_prefix (string, prefix for QM job input file), qmgau_job (is string, representing Gaussian path), nqm (integer, number of QM atoms); nlink (integer, number of link atoms), cln (integer, QoMMMa cycle number), qmkey (string, any extra keys specified by user for Gaussian job, default='None', i.e.'HF/STO-3G'), cha_mul1 and cha_mul2 are the charge and multiplicity of two states in MECP, given as list of two numbers, extra_basis is user specified basis set as a string (default='None'), and gau_head is used to assign memory and number of processors for Gaussian jobs, given as a string (default='None'). This main routine is called from QoMMMa main program at each cycle if MECP is requested. Before preparing new input files this routine will rename all Gaussian files created in previous cycle.</div>
</body>
</html>
